<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pop! Pop! Bubble Stop!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        html {
            height: 100%;
        }
        body {
            background: radial-gradient(circle, #5c97bf, #1c3d5a);
            font-family: 'Roboto', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            padding: 20px 0;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        #backgroundCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        h1 {
            margin-bottom: 10px;
            font-family: 'Fredoka One', cursive;
            font-size: 2.5em;
            color: white;
            text-shadow: 2px 2px 4px #4a2d6b;
            position: relative; 
            z-index: 2;
            text-align: center;
            max-width: 95vw;
        }

        #game-container {
            position: relative;
            aspect-ratio: 500 / 600;
            width: 500px;
            max-width: 90vw;
            max-height: 75vh;
            height: auto;
            background-color: rgba(214, 232, 250, 0.65);
            backdrop-filter: blur(4px);
            border: 5px solid rgba(163, 193, 227, 0.7);
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            border-radius: 10px;
            z-index: 1;
            transition: background-color 0.5s ease, transform 0.1s ease;
        }

        canvas {
            display: block;
            background-color: transparent;
            width: 100%;
            height: 100%;
            border-radius: 5px;
        }
        
        #ui-container {
            width: 500px;
            max-width: 90vw;
            margin-top: 15px;
            padding: 10px;
            box-sizing: border-box;
            background-color: rgba(214, 232, 250, 0.65);
            backdrop-filter: blur(4px);
            border: 5px solid rgba(163, 193, 227, 0.7);
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            color: #4a2d6b;
            font-size: 18px;
            font-weight: bold;
            z-index: 1;
        }

        #restart-button, #audio-toggle-button {
            padding: 5px 10px; font-size: 14px; font-weight: bold; cursor: pointer;
            border: 2px solid #4a2d6b; background-color: white; color: #4a2d6b; border-radius: 5px;
        }
        .next-bubble-area {
            display: flex; align-items: center; gap: 8px;
        }

        .overlay-screen {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            color: white;
            display: flex; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            border-radius: 5px;
            z-index: 10;
        }
        .overlay-screen h2 {
            font-family: 'Fredoka One', cursive; margin-top: 0; margin-bottom: 20px;
            font-size: 1.8em; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .overlay-screen button {
            margin-top: 20px; padding: 15px 30px;
            font-size: 1em; font-weight: bold; font-family: 'Fredoka One', cursive;
            cursor: pointer; border: 2px solid white; background-color: #8c6ba9;
            color: white; border-radius: 10px; transition: transform 0.1s ease;
        }
        .overlay-screen button:hover { transform: scale(1.05); }

        #rules-panel {
            aspect-ratio: 500 / 600;
            width: 500px;
            max-width: 90vw;
            max-height: 75vh;
            height: auto;
            background-color: rgba(28, 61, 90, 0.9);
            border: 5px solid rgba(163, 193, 227, 0.7);
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }
        #rules-panel h2 {
            flex-shrink: 0;
            margin-bottom: 15px;
        }
        .rules-text-container {
            flex-grow: 1;
            overflow-y: auto;
            text-align: left;
            padding-right: 10px;
            font-size: 1rem;
        }
        .rules-text-container ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .rules-text-container li {
            margin-bottom: 16px;
            line-height: 1.4;
        }
        .rules-text-container li strong {
            color: #ffc4e1;
        }
        #rules-panel button {
            flex-shrink: 0;
        }

        #redo-indicator {
            display: none;
            color: #fff38a;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        #game-over { display: none; }
        #start-overlay { display: none; }
        #level-up-overlay { display: none; }
        #level-up-overlay p { font-size: 0.8em; margin: 10px 0 20px 0; }

        @media (max-width: 480px) {
            h1 { font-size: 2em; }
            #ui-container { justify-content: center; font-size: 16px; gap: 8px; }
            #restart-button, #audio-toggle-button { padding: 10px 15px; }
            #rules-panel { padding: 15px; }
            .rules-text-container { font-size: 0.9rem; }
        }
    </style>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas>

    <h1>Pop! Pop! Bubble Stop!</h1>
    <div id="game-container">
        <canvas id="gameCanvas" width="500" height="600"></canvas>
        
        <div id="rules-overlay" class="overlay-screen">
            <div id="rules-panel">
                <h2>How to Play</h2>
                <div class="rules-text-container">
                    <ul>
                        <li><strong>Match 3+ Bubbles:</strong> Aim and shoot to create groups of 3 or more bubbles of the same color to pop them.</li>
                        <li><strong>üß± Brick Bubbles:</strong> These tough bubbles can't be matched. Pop adjacent bubbles (or hit with a bomb) twice to break them.</li>
                        <li><strong>üí£ Bomb Bubble:</strong> Clears a large area of bubbles. It will only crack, not destroy, a Brick Bubble.</li>
                        <li><strong>üåà Rainbow Bubble:</strong> A wild card! It takes on the color of any bubble it touches to help you make a match.</li>
                        <li><strong>üñåÔ∏è Paint Bubble:</strong> When it lands, it repaints all adjacent bubbles to its color, setting up huge combos.</li>
                        <li><strong>‚ö°Ô∏è Static Bubble:</strong> Popping a group of these triggers a chain reaction, zapping another random bubble of the same color on the board!</li>
                        <li><strong>+ Life Bubble:</strong> Pop this to remove one of your misses.</li>
                    </ul>
                </div>
                <button id="continue-button">Continue</button>
            </div>
        </div>

        <div id="level-up-overlay" class="overlay-screen">
            <h2 id="level-up-title">Level Up!</h2>
            <p id="level-up-message">Congratulations! Get ready for the next challenge.</p>
            <button id="level-up-continue-button">Continue</button>
        </div>
        <div id="start-overlay" class="overlay-screen"> <button id="play-button">Play!</button> </div>
        <div id="game-over" class="overlay-screen">
            <h2 id="end-message">Game Over</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button id="play-again-button">Play Again</button>
        </div>
    </div>
    
    <div id="ui-container">
        <div>Level: <span id="level">1</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>High Score: <span id="high-score">0</span></div>
        <div>Misses: <span id="miss-counter">0</span>/5</div>
        <div id="redo-indicator">Redo!</div>
        <div class="next-bubble-area">
            <span>Next:</span>
            <canvas id="nextBubbleCanvas" width="40" height="40"></canvas>
        </div>
        <button id="audio-toggle-button">Sound: ON</button>
        <button id="restart-button">Restart</button>
    </div>

<script>
const bgCanvas = document.getElementById('backgroundCanvas'), bgCtx = bgCanvas.getContext('2d');
const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
const gameContainer = document.getElementById('game-container');
const nextBubbleCanvas = document.getElementById('nextBubbleCanvas'), nextCtx = nextBubbleCanvas.getContext('2d');
const scoreEl = document.getElementById('score'), levelEl = document.getElementById('level'), gameOverEl = document.getElementById('game-over');
const highScoreEl = document.getElementById('high-score');
const missCounterEl = document.getElementById('miss-counter');
const redoIndicatorEl = document.getElementById('redo-indicator');
const finalScoreEl = document.getElementById('finalScore'), rulesOverlay = document.getElementById('rules-overlay');
const startOverlay = document.getElementById('start-overlay'), endMessageEl = document.getElementById('end-message');
const levelUpOverlay = document.getElementById('level-up-overlay'), levelUpMessageEl = document.getElementById('level-up-message');
const audioToggleButton = document.getElementById('audio-toggle-button');

const COLS = 12, ROWS = 14, SHOTS_UNTIL_LOSS = 5;
const BOMB_INTERVAL = 25 * 60;
const LEVEL_ROW_DROP_SPEEDS = { 1: 15 * 60, 2: 12 * 60, 3: 8 * 60 };
const FLOATING_POINTS_DURATION = 75, POP_PARTICLE_COUNT = 8, POP_PARTICLE_DURATION = 40;
const PADDING = 5;
const BUBBLE_RADIUS = (canvas.width - PADDING * 2) / (COLS * 2 + 1);
const HEX_WIDTH = BUBBLE_RADIUS * 2, HEX_HEIGHT = Math.sqrt(3) * BUBBLE_RADIUS;
const offsetX = PADDING + BUBBLE_RADIUS, offsetY = PADDING + BUBBLE_RADIUS;
const GAME_OVER_LINE_Y = canvas.height - BUBBLE_RADIUS * 4;

const ALL_COLORS = {
    1: ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A133FF', '#FFFF33'],
    2: ['#FFC4E1', '#A1C9F4', '#B2F7C3', '#FFF7AE', '#D9BFF5', '#FFD8B1'],
    3: ['#FFD700', '#C0C0C0', '#CD7F32', '#6A738B', '#50C878', '#E39695']
};
const LEVEL_RAINBOW_COLORS = {
    1: ['#FF5733', '#FFFF33', '#33FF57', '#3357FF', '#A133FF'],
    2: ['#FFC4E1', '#FFF7AE', '#B2F7C3', '#A1C9F4', '#D9BFF5'],
    3: ['#FFD700', '#E39695', '#50C878', '#6A738B', '#C0C0C0']
};
const LEVEL_UP_SCORES = { 1: 3500, 2: 8500 };
const LEVEL_BACKGROUNDS = { 1: 'rgba(214, 232, 250, 0.65)', 2: 'rgba(50, 60, 90, 0.7)', 3: 'rgba(80, 75, 70, 0.75)' };
const MAX_LEVEL = 3;
const SPECIALS = { 'RAINBOW': 'rainbow', 'LIFE': 'life', 'BOMB': 'bomb', 'BRICK': 'brick', 'PAINT': 'paint', 'STATIC': 'static' };
const isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);

let audioContext;
const sounds = {};
let lastAimAngle = 0, audioInitialized = false, isMuted = false;
let sizzleSoundSource = null, rainbowSoundSource = null;
let aimClickCounter = 0;

async function initAudio() {
    if (audioInitialized || audioContext) return;
    audioInitialized = true;
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') { await audioContext.resume(); }
        await createAllSounds();
    } catch (e) { console.error("Web Audio API failed to initialize.", e); }
}
function playSound(name, options = {}) {
    if (isMuted || !audioContext || !sounds[name]) return;
    const source = audioContext.createBufferSource();
    source.buffer = sounds[name];
    const gainNode = audioContext.createGain();
    gainNode.gain.setValueAtTime(options.gain !== undefined ? options.gain : 0.5, audioContext.currentTime);
    source.playbackRate.value = options.playbackRate || 1;
    source.connect(gainNode).connect(audioContext.destination);
    source.start(0);
}
function playLoopingSound(name, options = {}) {
    if (isMuted || !audioContext || !sounds[name]) return null;
    const source = audioContext.createBufferSource();
    source.buffer = sounds[name];
    source.loop = true;
    const gainNode = audioContext.createGain();
    gainNode.gain.setValueAtTime(options.gain !== undefined ? options.gain : 0.4, audioContext.currentTime);
    source.connect(gainNode).connect(audioContext.destination);
    source.start(0);
    return source;
}
function stopLoopingSound(source) {
    if (source) { source.stop(); }
    return null;
}
const soundGenerators = {
    click: async actx => { const d=0.05,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=Math.sin(6.28*2e3*p)*Math.pow(1-p,4)}return b;},
    shick: async actx => { const d=0.08,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++)c[i]=(Math.random()*2-1)*Math.pow(1-i/c.length,10);const o=new OfflineAudioContext(1,actx.sampleRate*d,actx.sampleRate),s=o.createBufferSource();s.buffer=b;const h=o.createBiquadFilter();h.type='highpass';h.frequency.value=1500;const p=o.createBiquadFilter();p.type='bandpass';p.frequency.value=4e3;p.Q.value=1.5;s.connect(h).connect(p).connect(o.destination);s.start();return await o.startRendering();},
    shoot: async actx => { const d=0.2,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=(Math.random()*2-1)*Math.pow(1-p,2)*.3+Math.sin(6.28*(2e3-p*1800)*p)*Math.pow(1-p,2)*.7}return b;},
    pop: async actx => { const d = 0.15, o = new OfflineAudioContext(1, actx.sampleRate * d, actx.sampleRate); const t = o.currentTime; const osc = o.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(50, t + 0.08); const oscGain = o.createGain(); oscGain.gain.setValueAtTime(0.7, t); oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.08); osc.connect(oscGain); const noiseDur = 0.02; const noiseBuf = actx.createBuffer(1, actx.sampleRate * noiseDur, actx.sampleRate); const noiseData = noiseBuf.getChannelData(0); for (let i = 0; i < noiseData.length; i++) noiseData[i] = Math.random() * 2 - 1; const noise = o.createBufferSource(); noise.buffer = noiseBuf; const noiseGain = o.createGain(); noiseGain.gain.setValueAtTime(0.1, t + 0.06); noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.06 + noiseDur); noise.connect(noiseGain); const lowpass = o.createBiquadFilter(); lowpass.type = 'lowpass'; lowpass.frequency.value = 800; oscGain.connect(lowpass); noiseGain.connect(lowpass); lowpass.connect(o.destination); osc.start(t); noise.start(t + 0.06); return await o.startRendering(); },
    bomb: async actx => { const d=0.8,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=(Math.random()*2-1)*Math.pow(1-p,4)+Math.sin(6.28*100*Math.pow(1-p,2)*p)*Math.pow(1-p,2)}return b;},
    life: async actx => { const d=0.3,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0),n1=Math.floor(actx.sampleRate*.1),n2=Math.floor(actx.sampleRate*.12);for(let i=0;i<n1;i++){const p=i/n1;c[i]=Math.sin(6.28*523.25*(i/actx.sampleRate))*Math.pow(1-p,2)*.8}for(let i=n2;i<c.length;i++){const p=(i-n2)/(c.length-n2);c[i]+=Math.sin(6.28*783.99*((i-n2)/actx.sampleRate))*Math.pow(1-p,2)*.8}return b;},
    levelUp: async actx => { const d=.1,n=[261.63,329.63,392,523.25],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,1.5)}}return b;},
    win: async actx => { const d=.12,n=[523.25,659.25,783.99,1046.5,783.99,1046.5],b=actx.createBuffer(1,actx.sampleRate*(d*n.length+.2),actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*(1-p)*.8}}return b;},
    lose: async actx => { const d=.25,n=[440,349.23,261.63,196],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,.5)*.7}}return b;},
    sizzle: async actx => { const d=1,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){c[i]=(Math.random()*2-1)*.4}const f=actx.createBiquadFilter();f.type='bandpass';f.frequency.value=2e3;f.Q.value=.5;const s=actx.createBufferSource();s.buffer=b;s.connect(f);const dest=actx.createMediaStreamDestination();f.connect(dest);return b;},
    rainbow: async actx => { const d=.15,n=[523.25,659.25,783.99,1046.5],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,2)*.8}}return b;},
    thump: async actx => { const d=0.15,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=Math.sin(Math.PI*p)*Math.pow(1-p,8)*(Math.random()*0.2-0.1)+Math.sin(6.28*60*p)*Math.pow(1-p,2)}return b;},
    crack: async actx => { const d=0.2,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++)c[i]=(Math.random()*2-1)*Math.pow(1-i/c.length,4);const o=new OfflineAudioContext(1,actx.sampleRate*d,actx.sampleRate),s=o.createBufferSource();s.buffer=b;const h=o.createBiquadFilter();h.type='highpass';h.frequency.value=800;s.connect(h).connect(o.destination);s.start();return await o.startRendering();},
    magical: async actx => { const d=0.1,n=[523.25,783.99,1046.5],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,2)*.5}}return b;}
};
async function createAllSounds() {
    const promises = Object.keys(soundGenerators).map(async name => {
        sounds[name] = await soundGenerators[name](audioContext);
    });
    await Promise.all(promises);
}

let grid, playerBubble, nextBubble, score, highScore, shotsFired, rowDropTimer, bombTimer, newRowsDropped;
let gridRowOffset = 0;
let isFiring = false, aim = { x: canvas.width / 2, y: 0 };
let popAnimations = [], floatingPoints = [], fireworks = [], rain = [], bombSparks = [], shockwaves = [];
let gameState = 'rules';
let backgroundBubbles = [];
let level, currentColors, rainbowGradientOffset;
let screenShake = { magnitude: 0, duration: 0 };
let comboAnnouncer = { text: '', life: 0, x: 0, y: 0 };
let staticSparks = [], staticBubbleSparks = [];

function updateLevelStyles(newLevel) {
    if (gameContainer && LEVEL_BACKGROUNDS[newLevel]) {
        gameContainer.style.backgroundColor = LEVEL_BACKGROUNDS[newLevel];
    }
}
function hexToRgba(hex, alpha) { if(!hex) return `rgba(0,0,0,${alpha})`; const r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return r?`rgba(${parseInt(r[1],16)},${parseInt(r[2],16)},${parseInt(r[3],16)},${alpha})`:`rgba(0,0,0,${alpha})`;}
function darkenColor(hex, percent) { if (!hex) return '#000000'; let f=parseInt(hex.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF; return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);}

function createBubble(row, col, color = null, type = 'normal') {
    if (color === null) color = currentColors[Math.floor(Math.random() * currentColors.length)];
    const x = offsetX + col * HEX_WIDTH + ((row + gridRowOffset) % 2) * BUBBLE_RADIUS;
    const y = offsetY + row * HEX_HEIGHT;
    const bubble = { row, col, x, y, color, type, vx: 0, vy: 0, wobble: 1, wobbleDecay: 0.05 };
    if (type === SPECIALS.BRICK) { bubble.health = 2; }
    return bubble;
}
function getGridColors() {
    const colors = new Set();
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (grid[r][c] && (grid[r][c].type === 'normal' || grid[r][c].type === 'static')) {
                colors.add(grid[r][c].color);
            }
        }
    }
    return colors.size > 0 ? Array.from(colors) : currentColors;
}
function generateNextBubble() {
    const r = Math.random();
    if (r < 0.05) {
        const color = currentColors[Math.floor(Math.random() * currentColors.length)];
        return { type: SPECIALS.PAINT, color };
    } else if (r < 0.10) {
        const color = getGridColors()[Math.floor(Math.random() * getGridColors().length)] || currentColors[0];
        return { type: SPECIALS.STATIC, color };
    }
    const availableColors = getGridColors();
    let color = availableColors[Math.floor(Math.random() * availableColors.length)];
    let type = 'normal';
    if (Math.random() < 0.05) { type = SPECIALS.RAINBOW; color = null; }
    return { x: canvas.width / 2, y: canvas.height - BUBBLE_RADIUS, color, type, vx: 0, vy: 0 };
}
function resetForNextLevel() {
    grid = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));
    shotsFired = 0; isFiring = false; rowDropTimer = 0; bombTimer = 0; aimClickCounter = 0; newRowsDropped = 0;
    popAnimations = []; floatingPoints = []; fireworks = []; rain = []; bombSparks = []; shockwaves = []; staticSparks = []; staticBubbleSparks = [];
    gridRowOffset = 0;

    const initialPaletteSize = Math.min(currentColors.length, 4);
    const initialColorPalette = currentColors.slice(0, initialPaletteSize);

    for (let r = 0; r < 4; r++) {
        for (let c = 0; c < COLS; c++) {
            const rand = Math.random();
            if (rand < 0.08) {
                grid[r][c] = createBubble(r, c, null, SPECIALS.BRICK);
            } else {
                const randomColor = initialColorPalette[Math.floor(Math.random() * initialColorPalette.length)];
                grid[r][c] = createBubble(r, c, randomColor);
            }
        }
    }

    if (level === 2 || level === 3) {
        let placed = false;
        while (!placed) {
            const r = Math.floor(Math.random() * 4);
            const c = Math.floor(Math.random() * COLS);
            if (grid[r][c] && grid[r][c].type === 'normal') {
                const color = grid[r][c].color;
                grid[r][c] = createBubble(r, c, color, SPECIALS.STATIC);
                placed = true;
            }
        }
    }

    const placeLifeBubble = (side) => {
        let r, c;
        const halfCols = Math.floor(COLS / 2);
        do {
            r = Math.floor(Math.random() * 2);
            c = (side === 'left') 
                ? Math.floor(Math.random() * halfCols) 
                : Math.floor(Math.random() * halfCols) + halfCols;
        } while (grid[r][c] && grid[r][c].type !== 'normal');
        grid[r][c] = createBubble(r, c, '#ffffff', SPECIALS.LIFE);
    };

    placeLifeBubble('left');
    placeLifeBubble('right');

    playerBubble = generateNextBubble();
    nextBubble = generateNextBubble();
    updateUI();
}
function init() {
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource);
    rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    score=0; shotsFired=0;
    highScore = parseInt(localStorage.getItem('bubblePopHighScore')) || 0;
    level = 1;
    updateLevelStyles(level);
    currentColors = ALL_COLORS[level];
    rainbowGradientOffset = 0;
    gridRowOffset = 0;
    resetForNextLevel();
    gameState = 'pregame';
    updateUI();
}
function updateUI() { 
    scoreEl.innerText=score; 
    highScoreEl.innerText = highScore;
    levelEl.innerText = level;
    missCounterEl.innerText = shotsFired; 
    redoIndicatorEl.style.display = (shotsFired === 4 && playerBubble && playerBubble.type === SPECIALS.PAINT) ? 'block' : 'none';
    nextCtx.clearRect(0,0,nextBubbleCanvas.width,nextBubbleCanvas.height); 
    drawBubble(nextCtx,{...nextBubble,x:nextBubbleCanvas.width/2,y:nextBubbleCanvas.height/2,radius:BUBBLE_RADIUS*0.8});
}

function draw3DSphere(context, x, y, radius, baseStyle) {
    const opacity = (level > 1) ? 0.80 : 0.65;
    if (typeof baseStyle === 'string') { context.fillStyle = hexToRgba(baseStyle, opacity); } else { context.fillStyle = baseStyle; }
    context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
    let glowGrad = context.createRadialGradient(x, y, 0, x, y, radius);
    glowGrad.addColorStop(0, 'rgba(255, 255, 255, 0.2)'); glowGrad.addColorStop(0.8, 'rgba(255, 255, 255, 0)');
    context.fillStyle = glowGrad; context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
    let shadowGrad = context.createRadialGradient(x + radius * 0.4, y + radius * 0.5, radius * 0.5, x, y, radius * 1.5);
    shadowGrad.addColorStop(0, 'rgba(0,0,0,0.3)'); shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
    context.fillStyle = shadowGrad; context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
    let highlightGrad = context.createRadialGradient(x - radius * 0.4, y - radius * 0.5, 0, x - radius * 0.4, y - radius * 0.5, radius * 0.6);
    highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)'); highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
    context.fillStyle = highlightGrad; context.beginPath(); context.arc(x - radius * 0.4, y - radius * 0.5, radius * 0.6, 0, Math.PI * 2); context.fill();
}
function drawJaggedLine(ctx, x1, y1, x2, y2, segments, jaggedness) {
    ctx.beginPath(); ctx.moveTo(x1, y1);
    const dx = x2 - x1, dy = y2 - y1; const len = Math.hypot(dx, dy);
    for (let i = 1; i < segments; i++) {
        const progress = i / segments;
        const normalX = dy / len, normalY = -dx / len;
        const newX = x1 + dx * progress + (Math.random() - 0.5) * normalX * jaggedness;
        const newY = y1 + dy * progress + (Math.random() - 0.5) * normalY * jaggedness;
        ctx.lineTo(newX, newY);
    }
    ctx.lineTo(x2, y2);
    ctx.stroke();
}
function drawBubble(context, bubble) {
    if (!bubble) return;
    const radius = bubble.radius || BUBBLE_RADIUS;
    const wobbleY = bubble.wobble > 0 ? Math.sin(bubble.wobble * Math.PI * 4) * bubble.wobble * 2 : 0;
    const x = bubble.x, y = bubble.y + wobbleY;

    if (bubble.type !== SPECIALS.BRICK) {
        draw3DSphere(context, x, y, radius, bubble.color);
    }

    ctx.save();
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    switch (bubble.type) {
        case SPECIALS.LIFE:
            draw3DSphere(context, x, y, radius, '#FFFFFF');
            ctx.strokeStyle = '#D00000'; ctx.lineWidth = 4; const plusSize = radius * 0.5; ctx.beginPath();
            ctx.moveTo(x, y - plusSize); ctx.lineTo(x, y + plusSize);
            ctx.moveTo(x - plusSize, y); ctx.lineTo(x + plusSize, y);
            ctx.stroke();
            break;
        case SPECIALS.BOMB:
            context.fillStyle = '#222222'; context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
            let shadowGrad = context.createRadialGradient(x + radius * 0.4, y + radius * 0.5, radius * 0.5, x, y, radius * 1.5); shadowGrad.addColorStop(0, 'rgba(0,0,0,0.4)'); shadowGrad.addColorStop(1, 'rgba(0,0,0,0)'); context.fillStyle = shadowGrad; context.fill();
            let highlightGrad = context.createRadialGradient(x - radius * 0.4, y - radius * 0.5, 0, x - radius * 0.4, y - radius * 0.5, radius * 0.6); highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.1)'); highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)'); context.fillStyle = highlightGrad; context.fill();
            const capHeight = radius * 0.4, capWidth = radius * 0.55, capY = y - radius * 0.8, capX = x - capWidth / 2; context.fillStyle = '#888888'; context.fillRect(capX, capY - capHeight, capWidth, capHeight); context.fillStyle = '#AAAAAA'; context.fillRect(capX, capY - capHeight, capWidth, capHeight * 0.3);
            const fuseBaseY = capY - capHeight, fuseLength = radius * 0.8, fuseTipY = fuseBaseY - fuseLength; context.strokeStyle = '#A5694B'; context.lineWidth = 3; context.beginPath(); context.moveTo(x, fuseBaseY); context.lineTo(x, fuseTipY); context.stroke(); context.lineWidth = 1;
            if (bubble === playerBubble && !isFiring && Math.random() < 0.7) {
                bombSparks.push({ x: x, y: fuseTipY, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2 - 1.5, life: 0, duration: 20, color: Math.random() < 0.5 ? 'yellow' : 'orange' });
            }
            break;
        case SPECIALS.RAINBOW:
            let rainbowGrad = context.createLinearGradient(x - radius, y - radius, x + radius, y + radius); const colors = LEVEL_RAINBOW_COLORS[level] || LEVEL_RAINBOW_COLORS[1]; const numColors = colors.length;
            for (let i = 0; i <= numColors * 2; i++) {
                const colorIndex = i % numColors; let position = (i / numColors + rainbowGradientOffset) % 1; rainbowGrad.addColorStop(position, colors[colorIndex]);
            }
            draw3DSphere(context, x, y, radius, rainbowGrad);
            break;
        case SPECIALS.BRICK:
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.clip();
            ctx.fillStyle = '#4a2d1a'; 
            ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
            
            ctx.strokeStyle = '#b0b0b0'; 
            ctx.lineWidth = 1.5;
            
            const brickHeight = radius * 0.5;
            const brickWidth = radius;

            for(let i = -2; i <= 2; i++) {
                const rowY = y + i * brickHeight;
                for(let j = -1; j <= 1; j++) {
                    const colX = x + j * brickWidth + ((i % 2) * (brickWidth / 2));
                    
                    const brickGrad = ctx.createLinearGradient(colX, rowY - brickHeight / 2, colX, rowY + brickHeight / 2);
                    brickGrad.addColorStop(0, '#c26a4a');
                    brickGrad.addColorStop(1, '#9e492a');
                    ctx.fillStyle = brickGrad;
                    
                    ctx.fillRect(colX - brickWidth/2, rowY - brickHeight/2, brickWidth, brickHeight);
                    ctx.strokeRect(colX - brickWidth/2, rowY - brickHeight/2, brickWidth, brickHeight);
                }
            }
            ctx.restore();
            
            if (bubble.health <= 1) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x - radius * 0.6, y - radius * 0.5);
                ctx.lineTo(x - radius * 0.2, y - radius * 0.2);
                ctx.lineTo(x, y + radius * 0.1);
                ctx.lineTo(x + radius * 0.3, y - radius * 0.3);
                ctx.lineTo(x + radius * 0.7, y + radius * 0.6);
                ctx.stroke();
            }
            break;
        case SPECIALS.PAINT:
            ctx.font = `${radius * 1.2}px 'Fredoka One'`; ctx.fillStyle = darkenColor(bubble.color, 0.4);
            ctx.fillText('üñåÔ∏è', x, y);
            break;
        case SPECIALS.STATIC:
            ctx.font = `${radius * 1.2}px 'Fredoka One'`; ctx.fillStyle = 'rgba(255, 255, 0, 0.9)'; ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
            ctx.strokeText('‚ö°', x, y); ctx.fillText('‚ö°', x, y);
            break;
    }
    ctx.restore();
}

function drawGrid() { for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c])drawBubble(ctx,grid[r][c]);}
function drawPopAnimations() { popAnimations.forEach(p=>{ const progress = p.life / p.duration; const alpha = 1 - progress; const currentSize = p.size * (1 - progress * 0.5); if (currentSize <= 0) return; let grad = ctx.createRadialGradient(p.x - currentSize * 0.3, p.y - currentSize * 0.3, 0, p.x, p.y, currentSize); const particleColor = p.color || '#cccccc'; const darkParticleColor = darkenColor(particleColor, 0.5); grad.addColorStop(0, hexToRgba('white', alpha * 0.8)); grad.addColorStop(0.5, hexToRgba(particleColor, alpha)); grad.addColorStop(1, hexToRgba(darkParticleColor, alpha)); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2); ctx.fill(); });}
function drawFloatingPoints() { ctx.font="bold 24px 'Fredoka One',cursive";ctx.textAlign='center';ctx.textBaseline='middle';floatingPoints.forEach(fp=>{const p=fp.life/fp.duration;const alpha=1-p*p;ctx.fillStyle=`rgba(255,255,255,${alpha})`;ctx.strokeStyle=`rgba(60,60,60,${alpha*0.8})`;ctx.lineWidth=4;ctx.strokeText(fp.text,fp.x,fp.y);ctx.fillText(fp.text,fp.x,fp.y)});ctx.lineWidth=1;}
function drawAimingLine() { if(aim.y>playerBubble.y-20)return;const angle=Math.atan2(aim.y-playerBubble.y,aim.x-playerBubble.x);ctx.beginPath();ctx.moveTo(playerBubble.x,playerBubble.y);ctx.lineTo(playerBubble.x+Math.cos(angle)*1e3,playerBubble.y+Math.sin(angle)*1e3);ctx.strokeStyle='rgba(255,255,255,0.4)';ctx.setLineDash([5,10]);ctx.lineWidth=3;ctx.stroke();ctx.setLineDash([]);}
function drawGameOverLine() { ctx.beginPath();ctx.moveTo(0,GAME_OVER_LINE_Y);ctx.lineTo(canvas.width,GAME_OVER_LINE_Y);ctx.strokeStyle='rgba(255,0,0,0.7)';ctx.lineWidth=3;ctx.setLineDash([10,5]);ctx.stroke();ctx.setLineDash([]);}
function drawFireworks() { fireworks.forEach(p=>{ctx.beginPath();ctx.fillStyle=p.color;ctx.arc(p.x,p.y,p.size,0,Math.PI*2);ctx.fill()});}
function drawRain() { ctx.strokeStyle='rgba(174,194,224,0.5)'; ctx.lineWidth=2; rain.forEach(p=>{ctx.beginPath();ctx.moveTo(p.x,p.y);ctx.lineTo(p.x,p.y+p.len);ctx.stroke()}); ctx.lineWidth=1;}
function drawBombSparks() { bombSparks.forEach(s=>{ctx.fillStyle=s.color;ctx.fillRect(s.x,s.y,2,2)}); }
function drawShockwaves() { ctx.save(); shockwaves.forEach(sw => { const easeOutQuad = t => t * (2 - t); const progress = easeOutQuad(sw.life / sw.duration); const fadeProgress = sw.life / sw.duration; const currentRadius = BUBBLE_RADIUS + (BUBBLE_RADIUS * 5.5) * progress; const alpha = 1 - fadeProgress; ctx.beginPath(); ctx.arc(sw.x, sw.y, currentRadius, 0, Math.PI * 2); ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.7})`; ctx.lineWidth = 10 * alpha; ctx.stroke(); }); ctx.restore();}
function drawComboAnnouncer() {
    if (comboAnnouncer.life <= 0) return;
    const progress = comboAnnouncer.life / 60;
    const scale = 1 + (1 - progress) * 0.5;
    const alpha = Math.min(1, progress * 2);
    ctx.save();
    ctx.font = `bold ${40 * scale}px 'Fredoka One', cursive`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.strokeStyle = `rgba(0, 0, 0, ${alpha * 0.7})`;
    ctx.lineWidth = 6;
    ctx.strokeText(comboAnnouncer.text, comboAnnouncer.x, comboAnnouncer.y);
    ctx.fillText(comboAnnouncer.text, comboAnnouncer.x, comboAnnouncer.y);
    ctx.restore();
}
function drawStaticSparks() {
    ctx.save(); ctx.lineWidth = 4;
    ctx.shadowBlur = 10; ctx.shadowColor = 'yellow';
    staticSparks.forEach(spark => {
        const progress = spark.life / spark.duration;
        const alpha = 1 - progress;
        ctx.strokeStyle = `rgba(255, 255, 224, ${alpha})`;
        drawJaggedLine(ctx, spark.fromX, spark.fromY, spark.toX, spark.toY, 10, 15);
    });
    ctx.restore();
}
function drawStaticBubbleSparks() {
    ctx.save();
    staticBubbleSparks.forEach(s => {
        const progress = s.life / s.duration;
        ctx.fillStyle = s.color;
        ctx.globalAlpha = 1 - progress;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.restore();
}

function updatePopAnimations() { for(let i=popAnimations.length-1;i>=0;i--){const p=popAnimations[i];p.life++;p.x+=p.vx;p.y+=p.vy;p.vx*=0.97;p.vy*=0.97;if(p.life>=p.duration){popAnimations.splice(i,1)}}}
function updateFloatingPoints() { for(let i=floatingPoints.length-1;i>=0;i--){const fp=floatingPoints[i];fp.life++;fp.y+=fp.vy;if(fp.life>=fp.duration){floatingPoints.splice(i,1)}}}
function updateFireworks() { for(let i=fireworks.length-1;i>=0;i--){const p=fireworks[i];p.x+=p.vx;p.y+=p.vy;p.vy+=0.02;p.size*=0.98;if(p.size<0.5)fireworks.splice(i,1)} if(Math.random()<0.05)createFirework();}
function updateRain() { for(let i=rain.length-1;i>=0;i--){const p=rain[i];p.y+=p.speed;if(p.y>canvas.height){p.y=-p.len;p.x=Math.random()*canvas.width}};}
function updateBombSparks() { for(let i=bombSparks.length-1;i>=0;i--){const s=bombSparks[i];s.life++;s.x+=s.vx;s.y+=s.vy;if(s.life>=s.duration)bombSparks.splice(i,1)}}
function updateShockwaves() { for (let i = shockwaves.length - 1; i >= 0; i--) { const sw = shockwaves[i]; sw.life++; if (sw.life >= sw.duration) { shockwaves.splice(i, 1); }}}
function updateStaticBubbleSparks() {
    for(let i = staticBubbleSparks.length - 1; i >= 0; i--) {
        const s = staticBubbleSparks[i];
        s.life++;
        if (s.life >= s.duration) {
            staticBubbleSparks.splice(i, 1);
        }
    }

    const allBubbles = grid.flat();
    if(playerBubble && !isFiring) allBubbles.push(playerBubble);

    allBubbles.forEach(bubble => {
        if (bubble && bubble.type === SPECIALS.STATIC) {
            if (Math.random() < 0.4) {
                 const angle = Math.random() * Math.PI * 2;
                 const radius = bubble.radius || BUBBLE_RADIUS;
                 staticBubbleSparks.push({
                     x: bubble.x + Math.cos(angle) * radius,
                     y: bubble.y + Math.sin(angle) * radius,
                     life: 0,
                     duration: 10 + Math.random() * 10,
                     size: Math.random() * 2 + 1,
                     color: Math.random() < 0.5 ? 'yellow' : 'white'
                 });
            }
        }
    });
}

function update() {
    updatePopAnimations(); updateFloatingPoints(); updateBombSparks(); updateShockwaves(); updateStaticBubbleSparks();
    if (screenShake.duration > 0) {
        screenShake.duration--;
        const sx = (Math.random() - 0.5) * screenShake.magnitude;
        const sy = (Math.random() - 0.5) * screenShake.magnitude;
        gameContainer.style.transform = `translate(${sx}px, ${sy}px)`;
    } else {
        gameContainer.style.transform = 'translate(0,0)';
    }
    if (comboAnnouncer.life > 0) comboAnnouncer.life--;
    for(let i=staticSparks.length-1; i>=0; i--) {
        staticSparks[i].life++;
        if (staticSparks[i].life >= staticSparks[i].duration) staticSparks.splice(i,1);
    }
    grid.flat().forEach(bubble => {
        if(bubble && bubble.wobble > 0) {
            bubble.wobble -= bubble.wobbleDecay;
        }
    });

    rainbowGradientOffset = (rainbowGradientOffset + 0.005) % 1;
    if(isFiring){playerBubble.x+=playerBubble.vx;playerBubble.y+=playerBubble.vy;if(playerBubble.x-BUBBLE_RADIUS<0||playerBubble.x+BUBBLE_RADIUS>canvas.width)playerBubble.vx*=-1;if(playerBubble.y-BUBBLE_RADIUS<0){snapBubble(null);return}for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c] && Math.hypot(playerBubble.x-grid[r][c].x,playerBubble.y-grid[r][c].y)<BUBBLE_RADIUS*2){snapBubble({r,c});return}}
    rowDropTimer++; if(rowDropTimer >= LEVEL_ROW_DROP_SPEEDS[level]){ addNewRow(); }
    bombTimer++; if(bombTimer >= BOMB_INTERVAL) { spawnBombBubble(); }
}

async function snapBubble(collidedCoords) { 
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource); rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    isFiring=false; playerBubble.vx=0; playerBubble.vy=0;
    let s=null; 
    if(collidedCoords===null){let d=Infinity;for(let c=0;c<COLS;c++)if(!grid[0][c]){const D=Math.abs(playerBubble.x-(offsetX+c*HEX_WIDTH+((0+gridRowOffset)%2)*BUBBLE_RADIUS));if(D<d){d=D;s={r:0,c}}}} 
    else{const n=getNeighbors(collidedCoords.r,collidedCoords.c);let d=Infinity;for(const N of n)if(!grid[N.r][N.c]){const x=offsetX+N.c*HEX_WIDTH+((N.r+gridRowOffset)%2)*BUBBLE_RADIUS,y=offsetY+N.r*HEX_HEIGHT,D=Math.hypot(playerBubble.x-x,playerBubble.y-y);if(D<d){d=D;s=N}}} 
    if(s===null){let d=Infinity;for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(!grid[r][c]){const x=offsetX+c*HEX_WIDTH+((r+gridRowOffset)%2)*BUBBLE_RADIUS,y=offsetY+r*HEX_HEIGHT,D=Math.hypot(playerBubble.x-x,playerBubble.y-y);if(D<d){d=D;s={r,c}}}} 
    if(s){
        grid[s.r][s.c]=createBubble(s.r,s.c,playerBubble.color,playerBubble.type);
        grid[s.r][s.c].wobble = 1;
        await handlePostSnap(s.r,s.c)
    }
    else{prepareNextShot()}
}
function createFloatingPoints(text, x, y) { floatingPoints.push({text,x,y,life:0,duration:FLOATING_POINTS_DURATION,vy:-0.7});}
function createPopEffect(x, y, color) { for(let i=0;i<POP_PARTICLE_COUNT;i++){const angle=Math.random()*Math.PI*2;const speed=Math.random()*2+1;popAnimations.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,life:0,duration:POP_PARTICLE_DURATION,color:color||'#ccc',size:Math.random()*5+3});}}
function triggerScreenShake(magnitude, duration) { screenShake.magnitude = magnitude; screenShake.duration = duration; }
function triggerComboAnnouncer(text) { comboAnnouncer.text = text; comboAnnouncer.life = 60; comboAnnouncer.x = canvas.width / 2; comboAnnouncer.y = canvas.height / 2; }

async function handlePostSnap(row, col) {
    let landedBubble = grid[row][col];
    if (!landedBubble) return;

    const coordsToPop = new Set();
    const damagedBricksThisTurn = new Set();
    
    if (landedBubble.type === SPECIALS.RAINBOW) {
        const neighbors = getNeighbors(row, col).map(n => grid[n.r]?.[n.c]).filter(b => b && (b.type === 'normal' || b.type === 'static'));
        const candidateColors = new Set(neighbors.map(n => n.color));
        let bestColor = null, maxMatchSize = 0;
        for (const color of candidateColors) {
            const potentialMatches = findMatches(row, col, color);
            if (potentialMatches.length > maxMatchSize) { maxMatchSize = potentialMatches.length; bestColor = color; }
        }
        landedBubble.color = (bestColor && maxMatchSize >= 2) ? bestColor : (neighbors[0]?.color || ALL_COLORS[level][0]);
        landedBubble.type = 'normal';
    } else if (landedBubble.type === SPECIALS.PAINT) {
        playSound('magical', { gain: 0.6 });
        getNeighbors(row, col).forEach(n => {
            const neighborBubble = grid[n.r]?.[n.c];
            if (neighborBubble && neighborBubble.type === 'normal') { neighborBubble.color = landedBubble.color; }
        });
        grid[row][col] = null;
        const matches = findMatches(row, col, landedBubble.color);
        if (matches.length >= 3) { matches.forEach(coord => coordsToPop.add(`${coord.r},${coord.c}`)); }
    }
    
    if (coordsToPop.size === 0) {
        if (landedBubble.type === 'bomb') {
            triggerScreenShake(8, 15); playSound('bomb', { gain: 0.6 });
            getBombAffectedCoords(row, col).forEach(coordStr => {
                const [r,c] = coordStr.split(',').map(Number);
                const bubble = grid[r]?.[c];
                if (bubble) {
                    if (bubble.type === SPECIALS.BRICK && !damagedBricksThisTurn.has(coordStr)) {
                        bubble.health--; damagedBricksThisTurn.add(coordStr);
                        if(bubble.health <= 0) coordsToPop.add(coordStr);
                    } else if (bubble.type !== SPECIALS.BRICK) { coordsToPop.add(coordStr); }
                }
            });
        } else if (landedBubble.type !== SPECIALS.BRICK) {
            const matches = findMatches(row, col);
            if (matches.length >= 3) { matches.forEach(coord => coordsToPop.add(`${coord.r},${coord.c}`)); }
        }
    }
    
    const coordsToCheck = Array.from(coordsToPop);
    for (const coordStr of coordsToCheck) {
        const [r, c] = coordStr.split(',').map(Number);
        const bubble = grid[r]?.[c];
        if(!bubble) continue;
        if(bubble.type === SPECIALS.STATIC) {
            playSound('magical', { gain: 0.5, playbackRate: 1.2 });
            const candidates = [];
            for(let r2=0; r2<ROWS; r2++) for(let c2=0; c2<COLS; c2++) {
                if (grid[r2][c2]?.color === bubble.color && !coordsToPop.has(`${r2},${c2}`)) { candidates.push({r: r2, c: c2}); }
            }
            if(candidates.length > 0) {
                const targetBubbleCoord = candidates[Math.floor(Math.random() * candidates.length)];
                coordsToPop.add(`${targetBubbleCoord.r},${targetBubbleCoord.c}`);
                const targetBubble = grid[targetBubbleCoord.r][targetBubbleCoord.c];
                staticSparks.push({ fromX: bubble.x, fromY: bubble.y, toX: targetBubble.x, toY: targetBubble.y, life: 0, duration: 15 });
            }
        }
    }
    
    const newlyBrokenBricks = new Set();
    for (const coordStr of coordsToPop) {
        const [r, c] = coordStr.split(',').map(Number);
        const poppingBubble = grid[r]?.[c];
        if (poppingBubble && poppingBubble.type === 'bomb') {
            continue;
        }
        getNeighbors(r, c).forEach(n => {
            const neighbor = grid[n.r]?.[n.c];
            const neighborCoordStr = `${n.r},${n.c}`;
            if(neighbor && neighbor.type === SPECIALS.BRICK && !damagedBricksThisTurn.has(neighborCoordStr)) {
                neighbor.health--; damagedBricksThisTurn.add(neighborCoordStr);
                if(neighbor.health <= 0) { newlyBrokenBricks.add(neighborCoordStr); }
            }
        });
    }
    if (newlyBrokenBricks.size > 0) playSound('crack', { gain: 0.8 });
    newlyBrokenBricks.forEach(brickCoord => coordsToPop.add(brickCoord));

    const floaters = findFloatingBubbles(coordsToPop);
    floaters.forEach(coord => { coordsToPop.add(`${coord.r},${coord.c}`); });

    if (coordsToPop.size > 0) {
        let comboCount = coordsToPop.size;
        let totalPoints = 0, dropPoints = 0, lifeBubblesPopped = 0, brickBonus = 0;
        let popCounter = 0;
        for (const coordStr of coordsToPop) {
            const [r, c] = coordStr.split(',').map(Number);
            const bubble = grid[r]?.[c];
            if (bubble) {
                if (bubble.type === SPECIALS.BRICK) {
                    brickBonus += 100;
                } else if (floaters.some(fb => `${fb.r},${fb.c}` === coordStr)) {
                    dropPoints += 100;
                } else {
                    totalPoints += 75;
                }
                
                if (bubble.type === 'life') lifeBubblesPopped++;
                else if (bubble.type !== 'bomb') { playSound('pop', { gain: 0.4, playbackRate: 1.0 + popCounter * 0.05 }); popCounter++; }
                createPopEffect(bubble.x, bubble.y, bubble.color);
                grid[r][c] = null;
            }
        }
        if (lifeBubblesPopped > 0) { playSound('life', { gain: 0.6 }); shotsFired = Math.max(0, shotsFired - lifeBubblesPopped); createFloatingPoints(`-${lifeBubblesPopped} Miss!`, canvas.width / 2, canvas.height / 2); }
        score += totalPoints + dropPoints + brickBonus;
        if(totalPoints > 0) createFloatingPoints(`+${totalPoints}`, landedBubble.x, landedBubble.y);
        if(dropPoints > 0) createFloatingPoints(`+${dropPoints} Drop!`, canvas.width/2, canvas.height * 0.5);
        if(brickBonus > 0) createFloatingPoints(`+${brickBonus} Brick!`, canvas.width / 2, canvas.height * 0.6);
        if (comboCount >= 15) { triggerComboAnnouncer("UNSTOPPABLE!"); triggerScreenShake(6, 12); }
        else if (comboCount >= 10) { triggerComboAnnouncer("SPECTACULAR!"); }
        else if (comboCount >= 6) { triggerComboAnnouncer("AWESOME!"); }
        else if (comboCount > 3) { createFloatingPoints(`Combo x${comboCount}`, canvas.width / 2, canvas.height / 2 + 40); }
    } else {
        const isRedo = shotsFired === 4 && landedBubble.type === SPECIALS.PAINT;
        if (!isRedo) {
            shotsFired++;
        }
    }

    updateUI();
    if (isGridEmpty()) {
        const bricksRemain = grid.flat().some(b => b?.type === SPECIALS.BRICK);
        if (bricksRemain) {
             endGame(false); 
        } else {
            if (level < MAX_LEVEL) {
                level++; updateLevelStyles(level); currentColors = ALL_COLORS[level]; gameState = 'levelup'; playSound('levelUp', { gain: 0.6 }); levelUpMessageEl.innerText = `Board Cleared! Moving to Level ${level}!`; levelUpOverlay.style.display = 'flex';
            } else { endGame(true); }
        }
        return;
    }
    if (level < MAX_LEVEL && score >= LEVEL_UP_SCORES[level]) { level++; updateLevelStyles(level); currentColors = ALL_COLORS[level]; gameState = 'levelup'; playSound('levelUp', { gain: 0.5 }); levelUpMessageEl.innerText = `You've reached Level ${level}! Get ready for a new board with new colors!`; levelUpOverlay.style.display = 'flex'; return; }
    for (let c = 0; c < COLS; c++) if (grid[ROWS - 1][c]) { endGame(false); return; }
    if (shotsFired >= SHOTS_UNTIL_LOSS) { endGame(false); return; }
    prepareNextShot();
}

function getBombAffectedCoords(row, col) {
    const affectedCoordsSet = new Set(); affectedCoordsSet.add(`${row},${col}`);
    const firstRing = getNeighbors(row, col);
    firstRing.forEach(coord => affectedCoordsSet.add(`${coord.r},${coord.c}`));
    firstRing.forEach(neighbor => { getNeighbors(neighbor.r, neighbor.c).forEach(secondNeighbor => { affectedCoordsSet.add(`${secondNeighbor.r},${secondNeighbor.c}`); }); });
    return affectedCoordsSet;
}
function createExplosionEffect(x, y) { for (let i = 0; i < 60; i++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 6 + 2; popAnimations.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 0, duration: POP_PARTICLE_DURATION + 30, color: Math.random() < 0.7 ? 'orange' : '#FFDD00', size: Math.random() * 8 + 5 });}}
function addNewRow() {
    for (let c = 0; c < COLS; c++) { if (grid[ROWS - 2][c]) { endGame(false); return; } }
    playSound('thump', {gain: 0.6});
    newRowsDropped++;
    const newRow = Array(COLS).fill(null);
    
    const addLifeBubble = (newRowsDropped > 0 && newRowsDropped % 2 === 0);
    const addStaticBubble = (newRowsDropped > 0 && newRowsDropped % 3 === 0);

    let lifeCol = -1;
    if(addLifeBubble) { lifeCol = Math.floor(Math.random() * COLS); }
    
    let staticCol = -1;
    if(addStaticBubble) { 
        do {
            staticCol = Math.floor(Math.random() * COLS);
        } while (staticCol === lifeCol);
    }

    for (let c = 0; c < COLS; c++) {
        const rand = Math.random();
        if (c === lifeCol) { 
            newRow[c] = createBubble(0, c, '#ffffff', 'life'); 
        } else if (c === staticCol) {
            const color = getGridColors()[Math.floor(Math.random() * getGridColors().length)] || currentColors[0];
            newRow[c] = createBubble(0, c, color, SPECIALS.STATIC);
        } else if (rand < 0.08) { 
            newRow[c] = createBubble(0, c, null, SPECIALS.BRICK); 
        } else { 
            newRow[c] = createBubble(0, c, null, 'normal'); 
        }
    }
    grid.unshift(newRow); grid.pop();
    gridRowOffset = (gridRowOffset + 1) % 2;
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const bubble = grid[r][c];
            if (bubble) {
                bubble.row = r;
                bubble.x = offsetX + c * HEX_WIDTH + ((r + gridRowOffset) % 2) * BUBBLE_RADIUS;
                bubble.y = offsetY + r * HEX_HEIGHT;
            }
        }
    }
    rowDropTimer = 0;
}
function spawnBombBubble() { nextBubble = { type: 'bomb', color: '#444' }; updateUI(); bombTimer = 0; }
function prepareNextShot() {
    if(gameState!=='playing')return;
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource); rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    playerBubble={...nextBubble, x:canvas.width/2, y:canvas.height - BUBBLE_RADIUS - 5};
    if(playerBubble.type === 'bomb') { sizzleSoundSource = playLoopingSound('sizzle', { gain: 0.15 }); }
    if(playerBubble.type === 'rainbow') { rainbowSoundSource = playLoopingSound('rainbow', { gain: 0.2 }); }
    nextBubble=generateNextBubble();
    updateUI();
}
function getNeighbors(r,c) { const p = (r + gridRowOffset) % 2, d=[{dr:0,dc:1},{dr:0,dc:-1},{dr:-1,dc:p-1},{dr:-1,dc:p},{dr:1,dc:p-1},{dr:1,dc:p}],n=[];for(const i of d){const nr=r+i.dr,nc=c+i.dc;if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS)n.push({r:nr,c:nc})}return n}
function findMatches(startR, startC, forceColor = null) {
    const startBubble = grid[startR]?.[startC];
    if (!startBubble || startBubble.type === SPECIALS.BRICK) { return []; }
    const matchColor = forceColor || startBubble.color;
    if(!matchColor) return [];
    const cluster = [], toVisit = [{ r: startR, c: startC }], visited = new Set([`${startR},${startC}`]);
    while (toVisit.length > 0) {
        const currentCoord = toVisit.shift();
        cluster.push(currentCoord);
        for (const neighborCoord of getNeighbors(currentCoord.r, currentCoord.c)) {
            const coordStr = `${neighborCoord.r},${neighborCoord.c}`;
            if (!visited.has(coordStr)) {
                const neighborBubble = grid[neighborCoord.r]?.[neighborCoord.c];
                if (neighborBubble && neighborBubble.type !== SPECIALS.BRICK) {
                    if (neighborBubble.color === matchColor || neighborBubble.type === 'life') {
                        visited.add(coordStr);
                        toVisit.push(neighborCoord);
                    }
                }
            }
        }
    }
    const colorBubbleCount = cluster.reduce((count, coord) => {
        const bubble = grid[coord.r][coord.c];
        return (bubble?.type === 'normal' || bubble?.type === 'static') ? count + 1 : count;
    }, 0);
    if (cluster.length >= 3 && colorBubbleCount > 0) { return cluster; }
    return [];
}
function findFloatingBubbles(coordsToIgnore = new Set()) {
    const anchored = new Set(), queue = [];
    for (let c = 0; c < COLS; c++) {
        const coordStr = `0,${c}`;
        if (grid[0][c] && !coordsToIgnore.has(coordStr)) {
            queue.push({ r: 0, c: c });
            anchored.add(coordStr);
        }
    }
    let head = 0;
    while (head < queue.length) {
        const current = queue[head++];
        for (const neighbor of getNeighbors(current.r, current.c)) {
            const neighborStr = `${neighbor.r},${neighbor.c}`;
            if (grid[neighbor.r][neighbor.c] && !anchored.has(neighborStr) && !coordsToIgnore.has(neighborStr)) {
                anchored.add(neighborStr);
                queue.push(neighbor);
            }
        }
    }
    const floating = [];
    for (let r = 0; r < ROWS; r++) { for (let c = 0; c < COLS; c++) { const coordStr = `${r},${c}`; if (grid[r][c] && !anchored.has(coordStr) && !coordsToIgnore.has(coordStr)) { floating.push({ r, c }); } } }
    return floating;
}
function isGridEmpty() {
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (grid[r][c] && grid[r][c].type !== SPECIALS.BRICK) {
                return false;
            }
        }
    }
    return true;
}
function endGame(isWinner) {
    gameState='gameover'; isFiring=false;
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource); rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    let message = '';
    if (score > highScore) { highScore = score; localStorage.setItem('bubblePopHighScore', highScore); message = isWinner ? 'You Win! New High Score!' : 'New High Score!'; } 
    else { message = isWinner ? 'You Win!' : 'Sorry, you lost!'; }
    endMessageEl.innerText = message;
    if(isWinner){ playSound('win', { gain: 0.5 }); createFirework(); } 
    else { playSound('lose', { gain: 0.5 }); createRain(); }
    finalScoreEl.innerText = score; gameOverEl.style.display='flex';
}
function createFirework() { const x=Math.random()*canvas.width*0.8+canvas.width*0.1; const y=Math.random()*canvas.height*0.5+canvas.height*0.1; const color=`hsl(${Math.random()*360},100%,50%)`; for(let i=0;i<50;i++){const angle=Math.random()*Math.PI*2;const speed=Math.random()*3+1;fireworks.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,color,size:Math.random()*2+1})}}
function createRain() { for(let i=0;i<100;i++){rain.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,len:Math.random()*20+10,speed:Math.random()*5+2})}}
function handleAimUpdate(clientX,clientY) {
    if(gameState!=='playing')return; const rect=canvas.getBoundingClientRect(); aim.x=(clientX-rect.left)*(canvas.width/rect.width); aim.y=(clientY-rect.top)*(canvas.height/rect.height);
    const currentAngle = Math.atan2(aim.y-playerBubble.y,aim.x-playerBubble.x); if (Math.abs(currentAngle - lastAimAngle) > 0.03) { aimClickCounter++; if (aimClickCounter % 3 === 0) { playSound('shick', { gain: 0.7 }); } lastAimAngle = currentAngle; }
}
function handleFire() {
    if(gameState!=='playing'||isFiring||aim.y>playerBubble.y-20)return; playSound('shoot', { gain: 0.25 });
    const angle=Math.atan2(aim.y-playerBubble.y,aim.x-playerBubble.x),speed=15; playerBubble.vx=Math.cos(angle)*speed; playerBubble.vy=Math.sin(angle)*speed; isFiring=true;
}

document.getElementById('continue-button').addEventListener('click',()=>{initAudio();playSound('click',{gain:0.4});rulesOverlay.style.display='none';startOverlay.style.display='flex'});
document.getElementById('play-button').addEventListener('click',()=>{initAudio();playSound('click',{gain:0.4});startOverlay.style.display='none';gameState='playing'});
document.getElementById('play-again-button').addEventListener('click',()=>{initAudio();playSound('click',{gain:0.4});gameOverEl.style.display='none';init();startOverlay.style.display='flex'});
document.getElementById('restart-button').addEventListener('click',()=>{initAudio();playSound('click',{gain:0.4});if(gameState==='playing'&&confirm('Are you sure you want to restart the game?')){init();startOverlay.style.display='flex'}else if(gameState!=='playing'){init();startOverlay.style.display='flex'}});
document.getElementById('level-up-continue-button').addEventListener('click', () => { initAudio(); playSound('click',{gain:0.4}); levelUpOverlay.style.display = 'none'; resetForNextLevel(); gameState = 'playing'; });
audioToggleButton.addEventListener('click', () => {
    isMuted = !isMuted; audioToggleButton.innerText = isMuted ? "Sound: OFF" : "Sound: ON";
    if (isMuted) { sizzleSoundSource = stopLoopingSound(sizzleSoundSource); rainbowSoundSource = stopLoopingSound(rainbowSoundSource); } 
    else { initAudio(); playSound('click', {gain: 0.4}); if (playerBubble && playerBubble.type === 'bomb') sizzleSoundSource = playLoopingSound('sizzle', { gain: 0.15 }); if (playerBubble && playerBubble.type === 'rainbow') { rainbowSoundSource = playLoopingSound('rainbow', { gain: 0.2 }); } }
});
if(isMobile){canvas.addEventListener('touchmove',e=>{e.preventDefault();handleAimUpdate(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});canvas.addEventListener('touchend',e=>{e.preventDefault();handleFire()},{passive:false})}else{canvas.addEventListener('mousemove',e=>{handleAimUpdate(e.clientX,e.clientY)});canvas.addEventListener('click',handleFire)}
function initBackground() { bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight; backgroundBubbles = []; let bubbleCount = 30; for (let i = 0; i < bubbleCount; i++) { backgroundBubbles.push({ x: Math.random() * bgCanvas.width, y: Math.random() * bgCanvas.height, radius: Math.random() * 25 + 10, speed: Math.random() * 1 + 0.5, opacity: Math.random() * 0.3 + 0.1 });}}
function updateBackgroundBubbles() { for (let i = 0; i < backgroundBubbles.length; i++) { const b = backgroundBubbles[i]; b.y -= b.speed; if (b.y < -b.radius) { b.y = bgCanvas.height + b.radius; b.x = Math.random() * bgCanvas.width; b.speed = Math.random() * 1 + 0.5; b.radius = Math.random() * 25 + 10; }}}
function drawBackgroundBubbles() { bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height); for (let i = 0; i < backgroundBubbles.length; i++) { const b = backgroundBubbles[i]; let grad = bgCtx.createRadialGradient( b.x - b.radius * 0.3, b.y - b.radius * 0.3, 0, b.x, b.y, b.radius ); grad.addColorStop(0, `rgba(255, 255, 255, ${b.opacity + 0.2})`); grad.addColorStop(1, `rgba(174, 222, 252, ${b.opacity})`); bgCtx.fillStyle = grad; bgCtx.beginPath(); bgCtx.arc(b.x, b.y, b.radius, 0, Math.PI * 2); bgCtx.fill();}}
window.addEventListener('resize', initBackground);

function gameLoop() {
    updateBackgroundBubbles(); drawBackgroundBubbles();
    if (gameState === 'playing') update();
    if (gameState === 'gameover') { if (fireworks.length > 0) updateFireworks(); if (rain.length > 0) updateRain(); }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();
    if(gameState==='playing')drawBubble(ctx,playerBubble);
    if(gameState==='playing'&&!isFiring)drawAimingLine();
    drawPopAnimations(); drawFloatingPoints(); drawBombSparks(); drawShockwaves(); drawGameOverLine();
    drawStaticSparks(); drawStaticBubbleSparks(); drawComboAnnouncer();
    if(gameState === 'gameover') { drawFireworks(); drawRain(); }
    requestAnimationFrame(gameLoop);
}

initBackground(); init(); gameLoop();
</script>
</body>
</html>
