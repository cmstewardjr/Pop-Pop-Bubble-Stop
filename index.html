<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pop! Pop! Bubble Stop!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        html {
            height: 100%;
        }
        body {
            background: radial-gradient(circle, #5c97bf, #1c3d5a);
            font-family: 'Roboto', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            padding: 20px 0;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        #backgroundCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        h1 {
            margin-bottom: 10px;
            font-family: 'Fredoka One', cursive;
            font-size: 2.5em;
            color: white;
            text-shadow: 2px 2px 4px #4a2d6b;
            position: relative; 
            z-index: 2;
            text-align: center;
            max-width: 95vw;
        }

        #game-container {
            position: relative;
            aspect-ratio: 500 / 600;
            width: 500px;
            max-width: 90vw;
            max-height: 75vh;
            height: auto;
            background-color: rgba(214, 232, 250, 0.65);
            backdrop-filter: blur(4px);
            border: 5px solid rgba(163, 193, 227, 0.7);
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            border-radius: 10px;
            z-index: 1;
            transition: background-color 0.5s ease, transform 0.1s ease;
        }

        canvas {
            display: block;
            background-color: transparent;
            width: 100%;
            height: 100%;
            border-radius: 5px;
        }
        
        #ui-container {
            width: 500px;
            max-width: 90vw;
            margin-top: 15px;
            padding: 10px;
            box-sizing: border-box;
            background: linear-gradient(to top, #34495e, #5c97bf);
            border: 5px solid rgba(163, 193, 227, 0.5);
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            color: #f0f0f0;
            font-size: 18px;
            font-weight: bold;
            z-index: 1;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }

        #restart-button, #audio-toggle-button, #pause-button {
            padding: 5px 10px; font-size: 14px; font-weight: bold; cursor: pointer;
            border: 2px solid #f0f0f0; background-color: transparent; color: #f0f0f0; border-radius: 5px;
            transition: background-color 0.2s ease;
        }
        #restart-button:hover, #audio-toggle-button:hover, #pause-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .next-bubble-area {
            display: flex; align-items: center; gap: 8px;
        }

        .overlay-screen {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            color: white;
            display: none; /* Changed from flex */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            border-radius: 5px;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .overlay-screen h2 {
            font-family: 'Fredoka One', cursive; margin-top: 0; margin-bottom: 20px;
            font-size: 1.8em; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .overlay-screen button {
            margin-top: 20px; padding: 15px 30px;
            font-size: 1em; font-weight: bold; font-family: 'Fredoka One', cursive;
            cursor: pointer; border: 2px solid white; background-color: #8c6ba9;
            color: white; border-radius: 10px; transition: transform 0.1s ease;
        }
        .overlay-screen button:hover { transform: scale(1.05); }

        #rules-panel {
            aspect-ratio: 500 / 600;
            width: 500px;
            max-width: 90vw;
            max-height: 75vh;
            height: auto;
            background-color: rgba(28, 61, 90, 0.9);
            border: 5px solid rgba(163, 193, 227, 0.7);
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }
        #rules-panel h2 {
            flex-shrink: 0;
            margin-bottom: 15px;
        }
        .rules-text-container {
            flex-grow: 1;
            overflow-y: auto;
            text-align: left;
            padding-right: 10px;
            font-size: 1rem;
        }
        .rules-text-container ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .rules-text-container li {
            margin-bottom: 16px;
            line-height: 1.4;
        }
        .rules-text-container li strong {
            color: #ffc4e1;
        }
        #rules-panel button {
            flex-shrink: 0;
        }

        #redo-indicator {
            display: none;
            color: #fff38a;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
        
        #game-over, #start-overlay, #pause-overlay, #level-up-overlay, #rules-overlay {
             display: none; 
        }

        @media (max-width: 480px) {
            h1 { font-size: 2em; }
            #ui-container { justify-content: center; font-size: 16px; gap: 8px; }
            #restart-button, #audio-toggle-button, #pause-button { padding: 10px 15px; }
            #rules-panel { padding: 15px; }
            .rules-text-container { font-size: 0.9rem; }
        }

        @media (max-height: 800px) {
            body { padding: 10px 0; }
            h1 { font-size: 2em; margin-bottom: 5px; }
            #game-container { max-height: 70vh; }
            #ui-container { margin-top: 10px; font-size: 16px; }
        }
    </style>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas>

    <h1>Pop! Pop! Bubble Stop!</h1>
    <div id="game-container">
        <canvas id="gameCanvas" width="500" height="600"></canvas>
        
        <div id="rules-overlay" class="overlay-screen">
            <div id="rules-panel">
                <h2>How to Play</h2>
                <div class="rules-text-container">
                    <ul>
                        <li><strong>Match 3+ Bubbles:</strong> Aim and shoot to create groups of 3 or more bubbles of the same color to pop them.</li>
                        <li><strong>üß± Brick Bubbles:</strong> These tough bubbles can't be matched. Pop adjacent bubbles (or hit with a bomb) twice to break them.</li>
                        <li><strong>üí£ Bomb Bubble:</strong> Clears a large area of bubbles. It will only crack, not destroy, a Brick Bubble.</li>
                        <li><strong>üåà Rainbow Bubble:</strong> A wild card! It takes on the color of any bubble it touches to help you make a match.</li>
                        <li><strong>üñåÔ∏è Paint Bubble:</strong> When it lands, it repaints all adjacent bubbles to its color, setting up huge combos.</li>
                        <li><strong>‚ö°Ô∏è Static Bubble:</strong> Popping a group of these triggers a chain reaction, zapping another random bubble of the same color on the board!</li>
                        <li><strong>+ Life Bubble:</strong> Pop this to remove one of your misses.</li>
                    </ul>
                </div>
                <button id="continue-button">Continue</button>
            </div>
        </div>
        
        <div id="pause-overlay" class="overlay-screen">
            <h2>Paused</h2>
            <button id="resume-button">Resume</button>
        </div>

        <div id="level-up-overlay" class="overlay-screen">
            <h2 id="level-up-title">Level Up!</h2>
            <p id="level-up-message">Congratulations! Get ready for the next challenge.</p>
            <button id="level-up-continue-button">Continue</button>
        </div>
        <div id="start-overlay" class="overlay-screen"> <button id="play-button">Play!</button> </div>
        <div id="game-over" class="overlay-screen">
            <h2 id="end-message">Game Over</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button id="play-again-button">Play Again</button>
        </div>
    </div>
    
    <div id="ui-container">
        <div>Level: <span id="level">1</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>High Score: <span id="high-score">0</span></div>
        <div>Misses: <span id="miss-counter">0</span>/5</div>
        <div id="redo-indicator">Redo!</div>
        <div class="next-bubble-area">
            <span>Next:</span>
            <canvas id="nextBubbleCanvas" width="40" height="40"></canvas>
        </div>
        <button id="pause-button">Pause</button>
        <button id="audio-toggle-button">Sound: ON</button>
        <button id="restart-button">Restart</button>
    </div>

<script>
const bgCanvas = document.getElementById('backgroundCanvas'), bgCtx = bgCanvas.getContext('2d');
const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
const gameContainer = document.getElementById('game-container');
const nextBubbleCanvas = document.getElementById('nextBubbleCanvas'), nextCtx = nextBubbleCanvas.getContext('2d');
const scoreEl = document.getElementById('score'), levelEl = document.getElementById('level'), gameOverEl = document.getElementById('game-over');
const highScoreEl = document.getElementById('high-score');
const missCounterEl = document.getElementById('miss-counter');
const redoIndicatorEl = document.getElementById('redo-indicator');
const finalScoreEl = document.getElementById('finalScore');
const rulesOverlay = document.getElementById('rules-overlay');
const startOverlay = document.getElementById('start-overlay'), endMessageEl = document.getElementById('end-message');
const levelUpOverlay = document.getElementById('level-up-overlay'), levelUpMessageEl = document.getElementById('level-up-message');
const pauseOverlay = document.getElementById('pause-overlay');
const audioToggleButton = document.getElementById('audio-toggle-button');
const pauseButton = document.getElementById('pause-button');
const resumeButton = document.getElementById('resume-button');

// --- SPLASH SCREEN SYSTEM ---
let isFirstLoad = true; // The master switch to ensure this only runs once per session.

// Splash screen timing and state variables (converted to frame counts for our loop)
const SPLASH_FADE_FRAMES = 90;  // Approx 1.5 seconds at 60fps
const SPLASH_HOLD_FRAMES = 120; // Approx 2.0 seconds at 60fps
let splashPhase = 'fade-in';
let splashTimer = 0;
let splashOpacity = 0;

// Image loader for the splash screen
const splashImage = new Image();
let splashImageLoaded = false;
splashImage.src = 'https://nerdrealm419.github.io/Go-Go-Monkey-Go-v1/splash-screen.png';
splashImage.onload = () => {
    splashImageLoaded = true;
};
// --- END SPLASH SCREEN SYSTEM ---

// --- ALL GAME LOGIC AND VARIABLES (UNCHANGED) ---
// (The large block of game logic functions goes here, exactly as it was originally)
const COLS = 12, ROWS = 14, SHOTS_UNTIL_LOSS = 5;
const BOMB_INTERVAL = 25 * 60;
const LEVEL_ROW_DROP_SPEEDS = { 1: 15 * 60, 2: 15 * 60, 3: 15 * 60, 4: 15 * 60 };
const FLOATING_POINTS_DURATION = 50, POP_PARTICLE_COUNT = 8, POP_PARTICLE_DURATION = 60;
const PADDING = 5;
const BUBBLE_RADIUS = (canvas.width - PADDING * 2) / (COLS * 2 + 1);
const HEX_WIDTH = BUBBLE_RADIUS * 2, HEX_HEIGHT = Math.sqrt(3) * BUBBLE_RADIUS;
const offsetX = PADDING + BUBBLE_RADIUS, offsetY = PADDING + BUBBLE_RADIUS;
const GAME_OVER_LINE_Y = canvas.height - BUBBLE_RADIUS * 4;
const COLLISION_RADIUS = BUBBLE_RADIUS * 1.9;

const ALL_COLORS = {
    1: ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A133FF', '#FFFF33'],
    2: ['#FFC4E1', '#A1C9F4', '#B2F7C3', '#FFF7AE', '#D9BFF5', '#FFD8B1'],
    3: ['#FFD700', '#C0C0C0', '#CD7F32', '#6A738B', '#50C878', '#E39695'],
    4: ['#E6E6FA', '#D8BFD8', '#B0E0E6', '#FFB6C1', '#C0C0C0', '#F0E68C']
};
const LEVEL_RAINBOW_COLORS = {
    1: ['#FF5733', '#FFFF33', '#33FF57', '#3357FF', '#A133FF'],
    2: ['#FFC4E1', '#FFF7AE', '#B2F7C3', '#A1C9F4', '#D9BFF5'],
    3: ['#FFD700', '#E39695', '#50C878', '#6A738B', '#C0C0C0'],
    4: ['#E6E6FA', '#D8BFD8', '#B0E0E6', '#FFB6C1', '#C0C0C0']
};
const LEVEL_UP_SCORES = { 1: 5000, 2: 10000, 3: 15000 };
const LEVEL_BACKGROUNDS = { 1: 'rgba(214, 232, 250, 0.65)', 2: 'rgba(50, 60, 90, 0.7)', 3: 'rgba(80, 75, 70, 0.75)', 4: 'rgba(45, 20, 60, 0.8)' };
const MAX_LEVEL = 4;
const SPECIALS = { 'RAINBOW': 'rainbow', 'LIFE': 'life', 'BOMB': 'bomb', 'BRICK': 'brick', 'PAINT': 'paint', 'STATIC': 'static' };
const isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);

let audioContext;
const sounds = {};
let lastAimAngle = 0, audioInitialized = false, isMuted = false;
let sizzleSoundSource = null, rainbowSoundSource = null;
let aimClickCounter = 0;

async function initAudio() {
    if (audioInitialized || audioContext) return;
    audioInitialized = true;
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') { await audioContext.resume(); }
        await createAllSounds();
    } catch (e) { console.error("Web Audio API failed to initialize.", e); }
}
function playSound(name, options = {}) {
    if (isMuted || !audioContext || !sounds[name]) return;
    const source = audioContext.createBufferSource();
    source.buffer = sounds[name];
    const gainNode = audioContext.createGain();
    gainNode.gain.setValueAtTime(options.gain !== undefined ? options.gain : 0.5, audioContext.currentTime);
    source.playbackRate.value = options.playbackRate || 1;
    source.connect(gainNode).connect(audioContext.destination);
    source.start(0);
}
function playLoopingSound(name, options = {}) {
    if (isMuted || !audioContext || !sounds[name] || (name === 'sizzle' && sizzleSoundSource) || (name === 'rainbow' && rainbowSoundSource)) return null;
    const source = audioContext.createBufferSource();
    source.buffer = sounds[name];
    source.loop = true;
    const gainNode = audioContext.createGain();
    gainNode.gain.setValueAtTime(options.gain !== undefined ? options.gain : 0.4, audioContext.currentTime);
    source.connect(gainNode).connect(audioContext.destination);
    source.start(0);
    return source;
}
function stopLoopingSound(source) {
    if (source) { source.stop(); }
    return null;
}
const soundGenerators = {
    click: async actx => { const d=0.05,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=Math.sin(6.28*2e3*p)*Math.pow(1-p,4)}return b;},
    shick: async actx => { const d=0.08,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++)c[i]=(Math.random()*2-1)*Math.pow(1-i/c.length,10);const o=new OfflineAudioContext(1,actx.sampleRate*d,actx.sampleRate),s=o.createBufferSource();s.buffer=b;const h=o.createBiquadFilter();h.type='highpass';h.frequency.value=1500;const p=o.createBiquadFilter();p.type='bandpass';p.frequency.value=4e3;p.Q.value=1.5;s.connect(h).connect(p).connect(o.destination);s.start();return await o.startRendering();},
    shoot: async actx => { const d=0.2,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=(Math.random()*2-1)*Math.pow(1-p,2)*.3+Math.sin(6.28*(2e3-p*1800)*p)*Math.pow(1-p,2)*.7}return b;},
    pop: async actx => { const d = 0.15, o = new OfflineAudioContext(1, actx.sampleRate * d, actx.sampleRate); const t = o.currentTime; const osc = o.createOscillator(); osc.type = 'sine'; osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(50, t + 0.08); const oscGain = o.createGain(); oscGain.gain.setValueAtTime(0.7, t); oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.08); osc.connect(oscGain); const noiseDur = 0.02; const noiseBuf = actx.createBuffer(1, actx.sampleRate * noiseDur, actx.sampleRate); const noiseData = noiseBuf.getChannelData(0); for (let i = 0; i < noiseData.length; i++) noiseData[i] = Math.random() * 2 - 1; const noise = o.createBufferSource(); noise.buffer = noiseBuf; const noiseGain = o.createGain(); noiseGain.gain.setValueAtTime(0.1, t + 0.06); noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.06 + noiseDur); noise.connect(noiseGain); const lowpass = o.createBiquadFilter(); lowpass.type = 'lowpass'; lowpass.frequency.value = 800; oscGain.connect(lowpass); noiseGain.connect(lowpass); lowpass.connect(o.destination); osc.start(t); noise.start(t + 0.06); return await o.startRendering(); },
    bomb: async actx => { const d=0.8,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=(Math.random()*2-1)*Math.pow(1-p,4)+Math.sin(6.28*100*Math.pow(1-p,2)*p)*Math.pow(1-p,2)}return b;},
    life: async actx => { const d=0.3,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0),n1=Math.floor(actx.sampleRate*.1),n2=Math.floor(actx.sampleRate*.12);for(let i=0;i<n1;i++){const p=i/n1;c[i]=Math.sin(6.28*523.25*(i/actx.sampleRate))*Math.pow(1-p,2)*.8}for(let i=n2;i<c.length;i++){const p=(i-n2)/(c.length-n2);c[i]+=Math.sin(6.28*783.99*((i-n2)/actx.sampleRate))*Math.pow(1-p,2)*.8}return b;},
    levelUp: async actx => { const d=.1,n=[261.63,329.63,392,523.25],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,1.5)}}return b;},
    win: async actx => { const d=.12,n=[523.25,659.25,783.99,1046.5,783.99,1046.5],b=actx.createBuffer(1,actx.sampleRate*(d*n.length+.2),actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*(1-p)*.8}}return b;},
    lose: async actx => { const d=.25,n=[440,349.23,261.63,196],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,.5)*.7}}return b;},
    sizzle: async actx => { const d=1,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){c[i]=(Math.random()*2-1)*.4}const f=actx.createBiquadFilter();f.type='bandpass';f.frequency.value=2e3;f.Q.value=.5;const s=actx.createBufferSource();s.buffer=b;s.connect(f);const dest=actx.createMediaStreamDestination();f.connect(dest);return b;},
    rainbow: async actx => { const d=.15,n=[523.25,659.25,783.99,1046.5],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,2)*.8}}return b;},
    thump: async actx => { const d=0.15,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++){const p=i/c.length;c[i]=Math.sin(Math.PI*p)*Math.pow(1-p,8)*(Math.random()*0.2-0.1)+Math.sin(6.28*60*p)*Math.pow(1-p,2)}return b;},
    crack: async actx => { const d=0.2,b=actx.createBuffer(1,actx.sampleRate*d,actx.sampleRate),c=b.getChannelData(0);for(let i=0;i<c.length;i++)c[i]=(Math.random()*2-1)*Math.pow(1-i/c.length,4);const o=new OfflineAudioContext(1,actx.sampleRate*d,actx.sampleRate),s=o.createBufferSource();s.buffer=b;const h=o.createBiquadFilter();h.type='highpass';h.frequency.value=800;s.connect(h).connect(o.destination);s.start();return await o.startRendering();},
    magical: async actx => { const d=0.1,n=[523.25,783.99,1046.5],b=actx.createBuffer(1,actx.sampleRate*d*n.length,actx.sampleRate),c=b.getChannelData(0);for(let t=0;t<n.length;t++){const s=Math.floor(actx.sampleRate*d*t),e=s+Math.floor(actx.sampleRate*d);for(let i=s;i<e;i++){const p=(i-s)/(e-s);c[i]=Math.sin(6.28*n[t]*((i-s)/actx.sampleRate))*Math.pow(1-p,2)*.5}}return b;}
};
async function createAllSounds() {
    const promises = Object.keys(soundGenerators).map(async name => {
        sounds[name] = await soundGenerators[name](audioContext);
    });
    await Promise.all(promises);
}

let grid, playerBubble, nextBubble, score, highScore, shotsFired, rowDropTimer, bombTimer, newRowsDropped;
let gridRowOffset = 0;
let isFiring = false, aim = { x: canvas.width / 2, y: 0 };
let popAnimations = [], floatingPoints = [], fireworks = [], rain = [], bombSparks = [], shockwaves = [];
let gameState = 'intro'; // <-- Default state
let backgroundBubbles = [];
let level, currentColors, rainbowGradientOffset;
let screenShake = { magnitude: 0, duration: 0 };
let comboAnnouncer = { text: '', life: 0, x: 0, y: 0 };
let staticSparks = [], staticBubbleSparks = [], glitterParticles = [];
let trajectory = { path: [], snapPoint: null };
// --- State object for the canvas-based intro ---
let introState = {
    text: '',
    scale: 0,
    opacity: 0,
    shakeDuration: 0,
    shakeMagnitude: 6
};

function updateLevelStyles(newLevel) {
    if (gameContainer && LEVEL_BACKGROUNDS[newLevel]) {
        gameContainer.style.backgroundColor = LEVEL_BACKGROUNDS[newLevel];
    }
}
function hexToRgba(hex, alpha) { if(!hex) return `rgba(0,0,0,${alpha})`; const r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return r?`rgba(${parseInt(r[1],16)},${parseInt(r[2],16)},${parseInt(r[3],16)},${alpha})`:`rgba(0,0,0,${alpha})`;}
function darkenColor(hex, percent) { if (!hex) return '#000000'; let f=parseInt(hex.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF; return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);}

function createBubble(row, col, color = null, type = 'normal') {
    if (color === null) color = currentColors[Math.floor(Math.random() * currentColors.length)];
    const x = offsetX + col * HEX_WIDTH + ((row + gridRowOffset) % 2) * BUBBLE_RADIUS;
    const y = offsetY + row * HEX_HEIGHT;
    const bubble = { row, col, x, y, color, type, vx: 0, vy: 0, wobble: 1, wobbleDecay: 0.05 };
    if (type === SPECIALS.BRICK) { bubble.health = 2; }
    return bubble;
}
function getGridColors() {
    const colors = new Set();
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (grid[r][c] && (grid[r][c].type === 'normal' || grid[r][c].type === 'static')) {
                colors.add(grid[r][c].color);
            }
        }
    }
    return colors.size > 0 ? Array.from(colors) : currentColors;
}
function generateNextBubble() {
    const r = Math.random();
    if (r < 0.05) {
        const color = currentColors[Math.floor(Math.random() * currentColors.length)];
        return { type: SPECIALS.PAINT, color };
    } else if (r < 0.10) {
        const color = getGridColors()[Math.floor(Math.random() * getGridColors().length)] || currentColors[0];
        return { type: SPECIALS.STATIC, color };
    }
    const availableColors = getGridColors();
    let color = availableColors[Math.floor(Math.random() * availableColors.length)];
    let type = 'normal';
    if (Math.random() < 0.05) { type = SPECIALS.RAINBOW; color = null; }
    return { x: canvas.width / 2, y: canvas.height - BUBBLE_RADIUS, color, type, vx: 0, vy: 0 };
}
function resetForNextLevel() {
    grid = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));
    shotsFired = 0; isFiring = false; rowDropTimer = 0; bombTimer = 0; aimClickCounter = 0; newRowsDropped = 0;
    popAnimations = []; floatingPoints = []; fireworks = []; rain = []; bombSparks = []; shockwaves = []; staticSparks = []; staticBubbleSparks = []; glitterParticles = [];
    gridRowOffset = 0;

    for (let r = 0; r < 4; r++) {
        for (let c = 0; c < COLS; c++) {
            const rand = Math.random();
            if (rand < 0.08) {
                grid[r][c] = createBubble(r, c, null, SPECIALS.BRICK);
            } else {
                const randomColor = currentColors[Math.floor(Math.random() * currentColors.length)];
                grid[r][c] = createBubble(r, c, randomColor);
            }
        }
    }

    if (level === 2 || level === 3 || level === 4) {
        let placed = false;
        while (!placed) {
            const r = Math.floor(Math.random() * 4);
            const c = Math.floor(Math.random() * COLS);
            if (grid[r][c] && grid[r][c].type === 'normal') {
                const color = grid[r][c].color;
                grid[r][c] = createBubble(r, c, color, SPECIALS.STATIC);
                placed = true;
            }
        }
    }

    const placeLifeBubble = (side) => {
        let r, c;
        const halfCols = Math.floor(COLS / 2);
        do {
            r = Math.floor(Math.random() * 2);
            c = (side === 'left') 
                ? Math.floor(Math.random() * halfCols) 
                : Math.floor(Math.random() * halfCols) + halfCols;
        } while (grid[r][c] && grid[r][c].type !== 'normal');
        grid[r][c] = createBubble(r, c, '#ffffff', SPECIALS.LIFE);
    };

    placeLifeBubble('left');
    placeLifeBubble('right');

    playerBubble = generateNextBubble();
    nextBubble = generateNextBubble();
    updateUI();
}
function init() {
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource);
    rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    score=0; shotsFired=0;
    highScore = parseInt(localStorage.getItem('bubblePopHighScore')) || 0;
    level = 1;
    updateLevelStyles(level);
    currentColors = ALL_COLORS[level];
    rainbowGradientOffset = 0;
    gridRowOffset = 0;
    resetForNextLevel();
    updateUI();
}
function updateUI() { 
    scoreEl.innerText=score; 
    highScoreEl.innerText = highScore;
    levelEl.innerText = level;
    missCounterEl.innerText = shotsFired; 
    redoIndicatorEl.style.display = (shotsFired === 4 && playerBubble && playerBubble.type === SPECIALS.PAINT) ? 'block' : 'none';
    nextCtx.clearRect(0,0,nextBubbleCanvas.width,nextBubbleCanvas.height); 
    if (nextBubble) {
        drawBubble(nextCtx,{...nextBubble,x:nextBubbleCanvas.width/2,y:nextBubbleCanvas.height/2,radius:BUBBLE_RADIUS*0.8});
    }
}

function draw3DSphere(context, x, y, radius, baseStyle, alpha = 1.0) {
    const opacity = (level > 1) ? 0.80 : 0.65;
    if (typeof baseStyle === 'string') { context.fillStyle = hexToRgba(baseStyle, opacity * alpha); } else { context.fillStyle = baseStyle; }
    context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
    let glowGrad = context.createRadialGradient(x, y, 0, x, y, radius);
    glowGrad.addColorStop(0, `rgba(255, 255, 255, ${0.2 * alpha})`); glowGrad.addColorStop(0.8, 'rgba(255, 255, 255, 0)');
    context.fillStyle = glowGrad; context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
    let shadowGrad = context.createRadialGradient(x + radius * 0.4, y + radius * 0.5, radius * 0.5, x, y, radius * 1.5);
    shadowGrad.addColorStop(0, `rgba(0,0,0,${0.3 * alpha})`); shadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
    context.fillStyle = shadowGrad; context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
    let highlightGrad = context.createRadialGradient(x - radius * 0.4, y - radius * 0.5, 0, x - radius * 0.4, y - radius * 0.5, radius * 0.6);
    highlightGrad.addColorStop(0, `rgba(255, 255, 255, ${0.8 * alpha})`); highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
    context.fillStyle = highlightGrad; context.beginPath(); context.arc(x - radius * 0.4, y - radius * 0.5, radius * 0.6, 0, Math.PI * 2); context.fill();
}
function drawJaggedLine(ctx, x1, y1, x2, y2, segments, jaggedness) {
    ctx.beginPath(); ctx.moveTo(x1, y1);
    const dx = x2 - x1, dy = y2 - y1; const len = Math.hypot(dx, dy);
    for (let i = 1; i < segments; i++) {
        const progress = i / segments;
        const normalX = dy / len, normalY = -dx / len;
        const newX = x1 + dx * progress + (Math.random() - 0.5) * normalX * jaggedness;
        const newY = y1 + dy * progress + (Math.random() - 0.5) * normalY * jaggedness;
        ctx.lineTo(newX, newY);
    }
    ctx.lineTo(x2, y2);
    ctx.stroke();
}
function drawBubble(context, bubble, alpha = 1.0) {
    if (!bubble) return;
    const radius = bubble.radius || BUBBLE_RADIUS;
    const wobbleY = bubble.wobble > 0 ? Math.sin(bubble.wobble * Math.PI * 4) * bubble.wobble * 2 : 0;
    const x = bubble.x, y = bubble.y + wobbleY;

    if (bubble.type !== SPECIALS.BRICK) {
        draw3DSphere(context, x, y, radius, bubble.color, alpha);
    }

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    switch (bubble.type) {
        case SPECIALS.LIFE:
            draw3DSphere(context, x, y, radius, '#FFFFFF', alpha);
            ctx.strokeStyle = '#D00000'; ctx.lineWidth = 4; const plusSize = radius * 0.5; ctx.beginPath();
            ctx.moveTo(x, y - plusSize); ctx.lineTo(x, y + plusSize);
            ctx.moveTo(x - plusSize, y); ctx.lineTo(x + plusSize, y);
            ctx.stroke();
            break;
        case SPECIALS.BOMB:
            context.fillStyle = '#222222'; context.beginPath(); context.arc(x, y, radius, 0, Math.PI * 2); context.fill();
            let shadowGrad = context.createRadialGradient(x + radius * 0.4, y + radius * 0.5, radius * 0.5, x, y, radius * 1.5); shadowGrad.addColorStop(0, 'rgba(0,0,0,0.4)'); shadowGrad.addColorStop(1, 'rgba(0,0,0,0)'); context.fillStyle = shadowGrad; context.fill();
            let highlightGrad = context.createRadialGradient(x - radius * 0.4, y - radius * 0.5, 0, x - radius * 0.4, y - radius * 0.5, radius * 0.6); highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.1)'); highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)'); context.fillStyle = highlightGrad; context.fill();
            const capHeight = radius * 0.4, capWidth = radius * 0.55, capY = y - radius * 0.8, capX = x - capWidth / 2; context.fillStyle = '#888888'; context.fillRect(capX, capY - capHeight, capWidth, capHeight); context.fillStyle = '#AAAAAA'; context.fillRect(capX, capY - capHeight, capWidth, capHeight * 0.3);
            const fuseBaseY = capY - capHeight, fuseLength = radius * 0.8, fuseTipY = fuseBaseY - fuseLength; context.strokeStyle = '#A5694B'; context.lineWidth = 3; context.beginPath(); context.moveTo(x, fuseBaseY); context.lineTo(x, fuseTipY); context.stroke(); context.lineWidth = 1;
            if (bubble === playerBubble && !isFiring && Math.random() < 0.7) {
                bombSparks.push({ x: x, y: fuseTipY, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2 - 1.5, life: 0, duration: 20, color: Math.random() < 0.5 ? 'yellow' : 'orange' });
            }
            break;
        case SPECIALS.RAINBOW:
            let rainbowGrad = context.createLinearGradient(x - radius, y - radius, x + radius, y + radius); const colors = LEVEL_RAINBOW_COLORS[level] || LEVEL_RAINBOW_COLORS[1]; const numColors = colors.length;
            for (let i = 0; i <= numColors * 2; i++) {
                const colorIndex = i % numColors; let position = (i / numColors + rainbowGradientOffset) % 1; rainbowGrad.addColorStop(position, colors[colorIndex]);
            }
            draw3DSphere(context, x, y, radius, rainbowGrad, alpha);
            break;
        case SPECIALS.BRICK:
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.clip(); 
            ctx.fillStyle = '#4a2d1a'; 
            ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
            ctx.strokeStyle = '#b0b0b0'; 
            ctx.lineWidth = 1.5;
            const brickHeight = radius * 0.5;
            const brickWidth = radius;
            for(let i = -2; i <= 2; i++) {
                const rowY = y + i * brickHeight;
                for(let j = -1; j <= 1; j++) {
                    const colX = x + j * brickWidth + ((i % 2) * (brickWidth / 2));
                    const brickGrad = ctx.createLinearGradient(colX, rowY - brickHeight / 2, colX, rowY + brickHeight / 2);
                    brickGrad.addColorStop(0, '#c26a4a'); brickGrad.addColorStop(1, '#9e492a');
                    ctx.fillStyle = brickGrad;
                    ctx.fillRect(colX - brickWidth/2, rowY - brickHeight/2, brickWidth, brickHeight);
                    ctx.strokeRect(colX - brickWidth/2, rowY - brickHeight/2, brickWidth, brickHeight);
                }
            }
            let brickShadowGrad = context.createRadialGradient(x + radius * 0.4, y + radius * 0.5, radius * 0.5, x, y, radius * 1.5);
            brickShadowGrad.addColorStop(0, 'rgba(0,0,0,0.4)'); brickShadowGrad.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = brickShadowGrad;
            context.fillRect(x - radius, y - radius, radius * 2, radius * 2);
            let brickHighlightGrad = context.createRadialGradient(x - radius * 0.4, y - radius * 0.5, 0, x - radius * 0.4, y - radius * 0.5, radius * 0.6);
            brickHighlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.5)'); brickHighlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            context.fillStyle = brickHighlightGrad;
            context.fillRect(x - radius, y - radius, radius * 2, radius * 2);
            ctx.restore();
            if (bubble.health <= 1) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(x - radius * 0.6, y - radius * 0.5); ctx.lineTo(x - radius * 0.2, y - radius * 0.2);
                ctx.lineTo(x, y + radius * 0.1); ctx.lineTo(x + radius * 0.3, y - radius * 0.3);
                ctx.lineTo(x + radius * 0.7, y + radius * 0.6);
                ctx.stroke();
            }
            break;
        case SPECIALS.PAINT:
            ctx.font = `${radius * 1.2}px 'Fredoka One'`; ctx.fillStyle = darkenColor(bubble.color, 0.4);
            ctx.fillText('üñåÔ∏è', x, y);
            break;
        case SPECIALS.STATIC:
            ctx.font = `${radius * 1.2}px 'Fredoka One'`; ctx.fillStyle = 'rgba(255, 255, 0, 0.9)'; ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
            ctx.strokeText('‚ö°', x, y); ctx.fillText('‚ö°', x, y);
            break;
    }
    ctx.restore();
}

function drawGrid() { if(!grid) return; for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c])drawBubble(ctx,grid[r][c]);}
function drawPopAnimations() {
    popAnimations.forEach(p => {
        const progress = p.life / p.duration;
        const alpha = 1 - progress;
        const currentSize = p.size * (1 - progress * 0.5);
        if (currentSize <= 0) return;

        if (p.isSimple) {
            // Fast, simple drawing for intro text pops
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // Original, more expensive drawing for game bubbles
            let grad = ctx.createRadialGradient(p.x - currentSize * 0.3, p.y - currentSize * 0.3, 0, p.x, p.y, currentSize);
            const particleColor = p.color || '#cccccc';
            const darkParticleColor = darkenColor(particleColor, 0.5);
            grad.addColorStop(0, hexToRgba('white', alpha * 0.8));
            grad.addColorStop(0.5, hexToRgba(particleColor, alpha));
            grad.addColorStop(1, hexToRgba(darkParticleColor, alpha));
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
            ctx.fill();
        }
    });
}
function drawFloatingPoints() { ctx.font="bold 24px 'Fredoka One',cursive";ctx.textAlign='center';ctx.textBaseline='middle';floatingPoints.forEach(fp=>{const p=fp.life/fp.duration;const alpha=1-p*p;ctx.fillStyle=`rgba(255,255,255,${alpha})`;ctx.strokeStyle=`rgba(60,60,60,${alpha*0.8})`;ctx.lineWidth=4;ctx.strokeText(fp.text,fp.x,fp.y);ctx.fillText(fp.text,fp.x,fp.y)});ctx.lineWidth=1;}
function drawAimingLine() { 
    if(gameState!=='playing'||!playerBubble||aim.y>playerBubble.y-20) return;
    if(!trajectory.path || trajectory.path.length === 0) return;
    
    ctx.setLineDash([5, 10]);
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.moveTo(trajectory.path[0].x, trajectory.path[0].y);
    for(let i = 1; i < trajectory.path.length; i++) {
        ctx.lineTo(trajectory.path[i].x, trajectory.path[i].y);
    }
    ctx.stroke();
    ctx.setLineDash([]);
    
    if(trajectory.snapPoint) {
        let ghostBubble = {...playerBubble, x: trajectory.snapPoint.x, y: trajectory.snapPoint.y, radius: BUBBLE_RADIUS};
        drawBubble(ctx, ghostBubble, 0.5);
    }
}
function drawGameOverLine() { ctx.beginPath();ctx.moveTo(0,GAME_OVER_LINE_Y);ctx.lineTo(canvas.width,GAME_OVER_LINE_Y);ctx.strokeStyle='rgba(255,0,0,0.7)';ctx.lineWidth=3;ctx.setLineDash([10,5]);ctx.stroke();ctx.setLineDash([]);}
function drawFireworks() { fireworks.forEach(p=>{ctx.beginPath();ctx.fillStyle=p.color;ctx.arc(p.x,p.y,p.size,0,Math.PI*2);ctx.fill()});}
function drawRain() { ctx.strokeStyle='rgba(174,194,224,0.5)'; ctx.lineWidth=2; rain.forEach(p=>{ctx.beginPath();ctx.moveTo(p.x,p.y);ctx.lineTo(p.x,p.y+p.len);ctx.stroke()}); ctx.lineWidth=1;}
function drawBombSparks() { bombSparks.forEach(s=>{ctx.fillStyle=s.color;ctx.fillRect(s.x,s.y,2,2)}); }
function drawShockwaves() { ctx.save(); shockwaves.forEach(sw => { const easeOutQuad = t => t * (2 - t); const progress = easeOutQuad(sw.life / sw.duration); const fadeProgress = sw.life / sw.duration; const currentRadius = BUBBLE_RADIUS + (BUBBLE_RADIUS * 5.5) * progress; const alpha = 1 - fadeProgress; ctx.beginPath(); ctx.arc(sw.x, sw.y, currentRadius, 0, Math.PI * 2); ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.7})`; ctx.lineWidth = 10 * alpha; ctx.stroke(); }); ctx.restore();}
function drawComboAnnouncer() {
    if (comboAnnouncer.life <= 0) return;
    const progress = comboAnnouncer.life / 60;
    const scale = 1 + (1 - progress) * 0.5;
    const alpha = Math.min(1, progress * 2);
    ctx.save();
    ctx.font = `bold ${40 * scale}px 'Fredoka One', cursive`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.strokeStyle = `rgba(0, 0, 0, ${alpha * 0.7})`;
    ctx.lineWidth = 6;
    ctx.strokeText(comboAnnouncer.text, comboAnnouncer.x, comboAnnouncer.y);
    ctx.fillText(comboAnnouncer.text, comboAnnouncer.x, comboAnnouncer.y);
    ctx.restore();
}
function drawStaticSparks() {
    ctx.save(); ctx.lineWidth = 4;
    ctx.shadowBlur = 10; ctx.shadowColor = 'yellow';
    staticSparks.forEach(spark => {
        const progress = spark.life / spark.duration;
        const alpha = 1 - progress;
        ctx.strokeStyle = `rgba(255, 255, 224, ${alpha})`;
        drawJaggedLine(ctx, spark.fromX, spark.fromY, spark.toX, spark.toY, 10, 15);
    });
    ctx.restore();
}
function drawStaticBubbleSparks() {
    ctx.save();
    staticBubbleSparks.forEach(s => {
        const progress = s.life / s.duration;
        ctx.fillStyle = s.color;
        ctx.globalAlpha = 1 - progress;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.restore();
}
function drawGlitterParticles() {
    if (!grid || level !== 4) return;
    ctx.save();
    glitterParticles.forEach(p => {
        const progress = p.life / p.duration;
        ctx.globalAlpha = 1 - progress;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * (1 - progress), 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.restore();
}

function updatePopAnimations() { for(let i=popAnimations.length-1;i>=0;i--){const p=popAnimations[i];p.life++;p.x+=p.vx;p.y+=p.vy;p.vx*=0.97;p.vy*=0.97;if(p.life>=p.duration){popAnimations.splice(i,1)}}}
function updateFloatingPoints() { for(let i=floatingPoints.length-1;i>=0;i--){const fp=floatingPoints[i];fp.life++;fp.y+=fp.vy;if(fp.life>=fp.duration){floatingPoints.splice(i,1)}}}
function updateFireworks() { for(let i=fireworks.length-1;i>=0;i--){const p=fireworks[i];p.x+=p.vx;p.y+=p.vy;p.vy+=0.02;p.size*=0.98;if(p.size<0.5)fireworks.splice(i,1)} if(Math.random()<0.05)createFirework();}
function updateRain() { for(let i=rain.length-1;i>=0;i--){const p=rain[i];p.y+=p.speed;if(p.y>canvas.height){p.y=-p.len;p.x=Math.random()*canvas.width}};}
function updateBombSparks() { for(let i=bombSparks.length-1;i>=0;i--){const s=bombSparks[i];s.life++;s.x+=s.vx;s.y+=s.vy;if(s.life>=s.duration)bombSparks.splice(i,1)}}
function updateShockwaves() { for (let i = shockwaves.length - 1; i >= 0; i--) { const sw = shockwaves[i]; sw.life++; if (sw.life >= sw.duration) { shockwaves.splice(i, 1); }}}
function updateStaticBubbleSparks() {
    for(let i = staticBubbleSparks.length - 1; i >= 0; i--) {
        const s = staticBubbleSparks[i];
        s.life++;
        if (s.life >= s.duration) {
            staticBubbleSparks.splice(i, 1);
        }
    }
    const allBubbles = grid.flat();
    if(playerBubble && !isFiring) allBubbles.push(playerBubble);
    allBubbles.forEach(bubble => {
        if (bubble && bubble.type === SPECIALS.STATIC) {
            if (Math.random() < 0.4) {
                 const angle = Math.random() * Math.PI * 2;
                 const radius = bubble.radius || BUBBLE_RADIUS;
                 staticBubbleSparks.push({
                     x: bubble.x + Math.cos(angle) * radius,
                     y: bubble.y + Math.sin(angle) * radius,
                     life: 0,
                     duration: 10 + Math.random() * 10,
                     size: Math.random() * 2 + 1,
                     color: Math.random() < 0.5 ? 'yellow' : 'white'
                 });
            }
        }
    });
}
function updateGlitterParticles() {
    if (!grid || level !== 4) {
        if (glitterParticles.length > 0) glitterParticles = [];
        return;
    }
    grid.flat().forEach(bubble => {
        if (bubble && Math.random() < 0.1) {
            const angle = Math.random() * Math.PI * 2;
            const radius = bubble.radius || BUBBLE_RADIUS;
            glitterParticles.push({
                x: bubble.x + Math.cos(angle) * radius * 0.8, y: bubble.y + Math.sin(angle) * radius * 0.8,
                vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5,
                life: 0, duration: 20 + Math.random() * 20,
                color: ['#FFFFFF', '#E6E6FA', '#FFD700'][Math.floor(Math.random() * 3)],
                size: Math.random() * 1.5 + 1
            });
        }
    });
    for (let i = glitterParticles.length - 1; i >= 0; i--) {
        const p = glitterParticles[i];
        p.life++; p.x += p.vx; p.y += p.vy;
        if (p.life >= p.duration) glitterParticles.splice(i, 1);
    }
}

function update() {
    updatePopAnimations(); updateFloatingPoints(); updateBombSparks(); updateShockwaves(); updateStaticBubbleSparks(); updateGlitterParticles();
    if (screenShake.duration > 0) {
        screenShake.duration--;
        const sx = (Math.random() - 0.5) * screenShake.magnitude;
        const sy = (Math.random() - 0.5) * screenShake.magnitude;
        gameContainer.style.transform = `translate(${sx}px, ${sy}px)`;
    } else {
        gameContainer.style.transform = 'translate(0,0)';
    }
    if (comboAnnouncer.life > 0) comboAnnouncer.life--;
    for(let i=staticSparks.length-1; i>=0; i--) {
        staticSparks[i].life++;
        if (staticSparks[i].life >= staticSparks[i].duration) staticSparks.splice(i,1);
    }
    grid.flat().forEach(bubble => {
        if(bubble && bubble.wobble > 0) {
            bubble.wobble -= bubble.wobbleDecay;
        }
    });

    rainbowGradientOffset = (rainbowGradientOffset + 0.005) % 1;
    if(isFiring && playerBubble){playerBubble.x+=playerBubble.vx;playerBubble.y+=playerBubble.vy;if(playerBubble.x-BUBBLE_RADIUS<0||playerBubble.x+BUBBLE_RADIUS>canvas.width)playerBubble.vx*=-1;if(playerBubble.y-BUBBLE_RADIUS<0){snapBubble(null);return}for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c] && Math.hypot(playerBubble.x-grid[r][c].x,playerBubble.y-grid[r][c].y)<COLLISION_RADIUS){snapBubble({r,c});return}}
    rowDropTimer++; if(rowDropTimer >= (LEVEL_ROW_DROP_SPEEDS[level] || 8 * 60)){ addNewRow(); addNewRow(); }
    bombTimer++; if(bombTimer >= BOMB_INTERVAL) { spawnBombBubble(); }
    if (gameState === 'playing' && !isFiring) trajectory = calculateTrajectory();
}

async function snapBubble(collidedCoords) { 
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource); rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    isFiring=false; if(playerBubble){playerBubble.vx=0; playerBubble.vy=0;}
    let s=null; 
    if(collidedCoords===null){let d=Infinity;for(let c=0;c<COLS;c++)if(!grid[0][c]){const D=Math.abs(playerBubble.x-(offsetX+c*HEX_WIDTH+((0+gridRowOffset)%2)*BUBBLE_RADIUS));if(D<d){d=D;s={r:0,c}}}} 
    else{const n=getNeighbors(collidedCoords.r,collidedCoords.c);let d=Infinity;for(const N of n)if(!grid[N.r][N.c]){const x=offsetX+N.c*HEX_WIDTH+((N.r+gridRowOffset)%2)*BUBBLE_RADIUS,y=offsetY+N.r*HEX_HEIGHT,D=Math.hypot(playerBubble.x-x,playerBubble.y-y);if(D<d){d=D;s=N}}} 
    if(s===null){let d=Infinity;for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(!grid[r][c]){const x=offsetX+c*HEX_WIDTH+((r+gridRowOffset)%2)*BUBBLE_RADIUS,y=offsetY+r*HEX_HEIGHT,D=Math.hypot(playerBubble.x-x,playerBubble.y-y);if(D<d){d=D;s={r,c}}}} 
    if(s && playerBubble){
        grid[s.r][s.c]=createBubble(s.r,s.c,playerBubble.color,playerBubble.type);
        grid[s.r][s.c].wobble = 1;
        await handlePostSnap(s.r,s.c)
    }
    else{prepareNextShot()}
}
function createFloatingPoints(text, x, y) { floatingPoints.push({text,x,y,life:0,duration:FLOATING_POINTS_DURATION,vy:-0.7});}

// --- KEY CHANGES ARE BELOW ---

// Original pop effect for in-game bubbles
function createPopEffect(x, y, color) { 
    for(let i=0; i<POP_PARTICLE_COUNT; i++){
        const angle=Math.random()*Math.PI*2;
        const speed=Math.random()*2+1;
        popAnimations.push({
            x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,life:0,
            duration:POP_PARTICLE_DURATION,
            color:color||'#ccc',size:Math.random()*5+3
        });
    }
}

// A faster, quicker version specifically for the intro text
function createIntroPopEffect(x, y, color) {
    const INTRO_POP_PARTICLE_COUNT = 4; // Fewer particles for better performance
    for (let i = 0; i < INTRO_POP_PARTICLE_COUNT; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 2; 
        popAnimations.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0,
            duration: 35,
            color: color || 'white',
            size: Math.random() * 3 + 1.5, // Slightly smaller particles
            isSimple: true // Flag for a faster drawing method
        });
    }
}


function triggerScreenShake(magnitude, duration) { screenShake.magnitude = magnitude; screenShake.duration = duration; }
function triggerComboAnnouncer(text) { comboAnnouncer.text = text; comboAnnouncer.life = 60; comboAnnouncer.x = canvas.width / 2; comboAnnouncer.y = canvas.height / 2; }

async function handlePostSnap(row, col) {
    let landedBubble = grid[row][col];
    if (!landedBubble) return;

    const coordsToPop = new Set();
    const damagedBricksThisTurn = new Set();
    
    if (landedBubble.type === SPECIALS.RAINBOW) {
        const neighbors = getNeighbors(row, col).map(n => grid[n.r]?.[n.c]).filter(b => b && (b.type === 'normal' || b.type === 'static'));
        const candidateColors = new Set(neighbors.map(n => n.color));
        let bestColor = null, maxMatchSize = 0;
        for (const color of candidateColors) {
            const potentialMatches = findMatches(row, col, color);
            if (potentialMatches.length > maxMatchSize) { maxMatchSize = potentialMatches.length; bestColor = color; }
        }
        landedBubble.color = (bestColor && maxMatchSize >= 2) ? bestColor : (neighbors[0]?.color || ALL_COLORS[level][0]);
        landedBubble.type = 'normal';
    } else if (landedBubble.type === SPECIALS.PAINT) {
        playSound('magical', { gain: 0.6 });
        getNeighbors(row, col).forEach(n => {
            const neighborBubble = grid[n.r]?.[n.c];
            if (neighborBubble && neighborBubble.type === 'normal') { neighborBubble.color = landedBubble.color; }
        });
        grid[row][col] = null;
        const matches = findMatches(row, col, landedBubble.color);
        if (matches.length >= 3) { matches.forEach(coord => coordsToPop.add(`${coord.r},${coord.c}`)); }
    }
    
    if (coordsToPop.size === 0) {
        if (landedBubble.type === 'bomb') {
            triggerScreenShake(8, 15); playSound('bomb', { gain: 0.6 });
            getBombAffectedCoords(row, col).forEach(coordStr => {
                const [r,c] = coordStr.split(',').map(Number);
                const bubble = grid[r]?.[c];
                if (bubble) {
                    if (bubble.type === SPECIALS.BRICK && !damagedBricksThisTurn.has(coordStr)) {
                        bubble.health--; damagedBricksThisTurn.add(coordStr);
                        if(bubble.health <= 0) coordsToPop.add(coordStr);
                    } else if (bubble.type !== SPECIALS.BRICK) { coordsToPop.add(coordStr); }
                }
            });
        } else if (landedBubble.type !== SPECIALS.BRICK) {
            const matches = findMatches(row, col);
            if (matches.length >= 3) { matches.forEach(coord => coordsToPop.add(`${coord.r},${coord.c}`)); }
        }
    }
    
    const finalCoordsToPop = new Set(coordsToPop);
    coordsToPop.forEach(coordStr => {
        const [r, c] = coordStr.split(',').map(Number);
        getNeighbors(r, c).forEach(neighborCoord => {
            const bubble = grid[neighborCoord.r]?.[neighborCoord.c];
            if(bubble && bubble.type === SPECIALS.LIFE) {
                finalCoordsToPop.add(`${neighborCoord.r},${neighborCoord.c}`);
            }
        });
    });

    const staticBubblesToPop = [];
    finalCoordsToPop.forEach(coordStr => {
        const [r, c] = coordStr.split(',').map(Number);
        const bubble = grid[r]?.[c];
        if (bubble && bubble.type === SPECIALS.STATIC) {
            staticBubblesToPop.push(bubble);
        }
    });
    if (staticBubblesToPop.length > 0) {
        playSound('magical', { gain: 0.5, playbackRate: 1.2 });
        staticBubblesToPop.forEach(staticBubble => {
            const candidates = [];
            for (let r2 = 0; r2 < ROWS; r2++) {
                for (let c2 = 0; c2 < COLS; c2++) {
                    const coordStr = `${r2},${c2}`;
                    if (grid[r2][c2]?.color === staticBubble.color && !finalCoordsToPop.has(coordStr)) {
                         candidates.push({ r: r2, c: c2 });
                    }
                }
            }
            if (candidates.length > 0) {
                const targetBubbleCoord = candidates[Math.floor(Math.random() * candidates.length)];
                finalCoordsToPop.add(`${targetBubbleCoord.r},${targetBubbleCoord.c}`);
                const targetBubble = grid[targetBubbleCoord.r][targetBubbleCoord.c];
                staticSparks.push({ fromX: staticBubble.x, fromY: staticBubble.y, toX: targetBubble.x, toY: targetBubble.y, life: 0, duration: 15 });
            }
        });
    }

    const newlyBrokenBricks = new Set();
    for (const coordStr of finalCoordsToPop) {
        const [r, c] = coordStr.split(',').map(Number);
        const poppingBubble = grid[r]?.[c];
        if (poppingBubble && poppingBubble.type === 'bomb') { continue; }
        getNeighbors(r, c).forEach(n => {
            const neighbor = grid[n.r]?.[n.c];
            const neighborCoordStr = `${n.r},${n.c}`;
            if(neighbor && neighbor.type === SPECIALS.BRICK && !damagedBricksThisTurn.has(neighborCoordStr)) {
                neighbor.health--; damagedBricksThisTurn.add(neighborCoordStr);
                if(neighbor.health <= 0) { newlyBrokenBricks.add(neighborCoordStr); }
            }
        });
    }
    if (newlyBrokenBricks.size > 0) playSound('crack', { gain: 0.8 });
    newlyBrokenBricks.forEach(brickCoord => finalCoordsToPop.add(brickCoord));

    const floaters = findFloatingBubbles(finalCoordsToPop);
    floaters.forEach(coord => { finalCoordsToPop.add(`${coord.r},${coord.c}`); });

    if (finalCoordsToPop.size > 0) {
        let comboCount = finalCoordsToPop.size;
        let totalPoints = 0, dropPoints = 0, lifeBubblesPopped = 0, brickBonus = 0;
        let popCounter = 0;
        for (const coordStr of finalCoordsToPop) {
            const [r, c] = coordStr.split(',').map(Number);
            const bubble = grid[r]?.[c];
            if (bubble) {
                if (bubble.type === SPECIALS.BRICK) {
                    brickBonus += 100;
                } else if (floaters.some(fb => `${fb.r},${fb.c}` === coordStr)) {
                    dropPoints += 50;
                } else if (bubble.type !== SPECIALS.LIFE) {
                    totalPoints += 75;
                }
                
                if (bubble.type === 'life') lifeBubblesPopped++;
                else if (bubble.type !== 'bomb') { playSound('pop', { gain: 0.4, playbackRate: 1.0 + popCounter * 0.05 }); popCounter++; }
                createPopEffect(bubble.x, bubble.y, bubble.color);
                grid[r][c] = null;
            }
        }
        if (lifeBubblesPopped > 0) { playSound('life', { gain: 0.6 }); shotsFired = Math.max(0, shotsFired - lifeBubblesPopped); createFloatingPoints(`-${lifeBubblesPopped} Miss!`, canvas.width / 2, canvas.height / 2); }
        score += totalPoints + dropPoints + brickBonus;
        if(totalPoints > 0) createFloatingPoints(`+${totalPoints}`, landedBubble.x, landedBubble.y);
        if(dropPoints > 0) createFloatingPoints(`+${dropPoints} Drop!`, canvas.width/2, canvas.height * 0.5);
        if(brickBonus > 0) createFloatingPoints(`+${brickBonus} Brick!`, canvas.width / 2, canvas.height * 0.6);
        if (comboCount >= 15) { triggerComboAnnouncer("UNSTOPPABLE!"); triggerScreenShake(6, 12); }
        else if (comboCount >= 10) { triggerComboAnnouncer("SPECTACULAR!"); }
        else if (comboCount >= 6) { triggerComboAnnouncer("AWESOME!"); }
        else if (comboCount > 3) { createFloatingPoints(`Combo x${comboCount}`, canvas.width / 2, canvas.height / 2 + 40); }
    } else {
        const isRedo = shotsFired === 4 && landedBubble.type === SPECIALS.PAINT;
        if (!isRedo) {
            shotsFired++;
        }
    }

    updateUI();
    if (isGridEmpty()) {
        const bricksRemain = grid.flat().some(b => b?.type === SPECIALS.BRICK);
        if (bricksRemain) {
             endGame(false); 
        } else {
            if (level < MAX_LEVEL) {
                level++; updateLevelStyles(level); currentColors = ALL_COLORS[level]; gameState = 'levelup'; playSound('levelUp', { gain: 0.6 }); levelUpMessageEl.innerText = `Board Cleared! Moving to Level ${level}!`; levelUpOverlay.style.display = 'flex';
            } else { endGame(true); }
        }
        return;
    }
    if (level < MAX_LEVEL && score >= LEVEL_UP_SCORES[level]) { level++; updateLevelStyles(level); currentColors = ALL_COLORS[level]; gameState = 'levelup'; playSound('levelUp', { gain: 0.5 }); levelUpMessageEl.innerText = `You've reached Level ${level}! Get ready for a new board with new colors!`; levelUpOverlay.style.display = 'flex'; return; }
    for (let c = 0; c < COLS; c++) if (grid[ROWS - 1][c]) { endGame(false); return; }
    if (shotsFired >= SHOTS_UNTIL_LOSS) { endGame(false); return; }
    prepareNextShot();
}

function getBombAffectedCoords(row, col) {
    const affectedCoordsSet = new Set(); affectedCoordsSet.add(`${row},${col}`);
    const firstRing = getNeighbors(row, col);
    firstRing.forEach(coord => affectedCoordsSet.add(`${coord.r},${coord.c}`));
    firstRing.forEach(neighbor => { getNeighbors(neighbor.r, neighbor.c).forEach(secondNeighbor => { affectedCoordsSet.add(`${secondNeighbor.r},${secondNeighbor.c}`); }); });
    return affectedCoordsSet;
}
function createExplosionEffect(x, y) { for (let i = 0; i < 60; i++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 6 + 2; popAnimations.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 0, duration: POP_PARTICLE_DURATION + 30, color: Math.random() < 0.7 ? 'orange' : '#FFDD00', size: Math.random() * 8 + 5 });}}
function addNewRow() {
    for (let c = 0; c < COLS; c++) { if (grid[ROWS - 2][c]) { endGame(false); return; } }
    playSound('thump', {gain: 0.6});
    newRowsDropped++;
    const newRow = Array(COLS).fill(null);
    
    const addLifeBubble = (newRowsDropped > 0 && newRowsDropped % 2 === 0);
    const addStaticBubble = (newRowsDropped > 0 && newRowsDropped % 3 === 0);

    let lifeCol = -1;
    if(addLifeBubble) { lifeCol = Math.floor(Math.random() * COLS); }
    
    let staticCol = -1;
    if(addStaticBubble) { 
        do {
            staticCol = Math.floor(Math.random() * COLS);
        } while (staticCol === lifeCol);
    }

    for (let c = 0; c < COLS; c++) {
        const rand = Math.random();
        if (c === lifeCol) { 
            newRow[c] = createBubble(0, c, '#ffffff', 'life'); 
        } else if (c === staticCol) {
            const color = getGridColors()[Math.floor(Math.random() * getGridColors().length)] || currentColors[0];
            newRow[c] = createBubble(0, c, color, SPECIALS.STATIC);
        } else if (rand < 0.08) { 
            newRow[c] = createBubble(0, c, null, SPECIALS.BRICK); 
        } else { 
            newRow[c] = createBubble(0, c, null, 'normal'); 
        }
    }
    grid.unshift(newRow); grid.pop();
    gridRowOffset = (gridRowOffset + 1) % 2;
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const bubble = grid[r][c];
            if (bubble) {
                bubble.row = r;
                bubble.x = offsetX + c * HEX_WIDTH + ((r + gridRowOffset) % 2) * BUBBLE_RADIUS;
                bubble.y = offsetY + r * HEX_HEIGHT;
            }
        }
    }
    rowDropTimer = 0;
}
function spawnBombBubble() { nextBubble = { type: 'bomb', color: '#444' }; updateUI(); bombTimer = 0; }
function prepareNextShot() {
    if(gameState!=='playing' && gameState!=='pregame' && gameState!=='levelup') return;
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource); rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    playerBubble={...nextBubble, x:canvas.width/2, y:canvas.height - BUBBLE_RADIUS - 5};
    if(playerBubble.type === 'bomb') { sizzleSoundSource = playLoopingSound('sizzle', { gain: 0.15 }); }
    if(playerBubble.type === 'rainbow') { rainbowSoundSource = playLoopingSound('rainbow', { gain: 0.2 }); }
    nextBubble=generateNextBubble();
    updateUI();
}
function getNeighbors(r,c) { const p = (r + gridRowOffset) % 2, d=[{dr:0,dc:1},{dr:0,dc:-1},{dr:-1,dc:p-1},{dr:-1,dc:p},{dr:1,dc:p-1},{dr:1,dc:p}],n=[];for(const i of d){const nr=r+i.dr,nc=c+i.dc;if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS)n.push({r:nr,c:nc})}return n}
function findMatches(startR, startC, forceColor = null) {
    const startBubble = grid[startR]?.[startC];
    if (!startBubble || startBubble.type === SPECIALS.BRICK) { return []; }
    const matchColor = forceColor || startBubble.color;
    if(!matchColor) return [];
    const cluster = [], toVisit = [{ r: startR, c: startC }], visited = new Set([`${startR},${startC}`]);
    while (toVisit.length > 0) {
        const currentCoord = toVisit.shift();
        cluster.push(currentCoord);
        for (const neighborCoord of getNeighbors(currentCoord.r, currentCoord.c)) {
            const coordStr = `${neighborCoord.r},${neighborCoord.c}`;
            if (!visited.has(coordStr)) {
                const neighborBubble = grid[neighborCoord.r]?.[neighborCoord.c];
                if (neighborBubble && neighborBubble.color === matchColor && neighborBubble.type !== SPECIALS.BRICK) {
                    visited.add(coordStr);
                    toVisit.push(neighborCoord);
                }
            }
        }
    }
    return cluster;
}
function findFloatingBubbles(coordsToIgnore = new Set()) {
    const anchored = new Set(), queue = [];
    for (let c = 0; c < COLS; c++) {
        const coordStr = `0,${c}`;
        if (grid[0][c] && !coordsToIgnore.has(coordStr)) {
            queue.push({ r: 0, c: c });
            anchored.add(coordStr);
        }
    }
    let head = 0;
    while (head < queue.length) {
        const current = queue[head++];
        for (const neighbor of getNeighbors(current.r, current.c)) {
            const neighborStr = `${neighbor.r},${neighbor.c}`;
            if (grid[neighbor.r]?.[neighbor.c] && !anchored.has(neighborStr) && !coordsToIgnore.has(neighborStr)) {
                anchored.add(neighborStr);
                queue.push(neighbor);
            }
        }
    }
    const floating = [];
    for (let r = 0; r < ROWS; r++) { for (let c = 0; c < COLS; c++) { const coordStr = `${r},${c}`; if (grid[r][c] && !anchored.has(coordStr) && !coordsToIgnore.has(coordStr)) { floating.push({ r, c }); } } }
    return floating;
}
function isGridEmpty() {
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (grid[r][c] && grid[r][c].type !== SPECIALS.BRICK) {
                return false;
            }
        }
    }
    return true;
}
function endGame(isWinner) {
    gameState='gameover'; isFiring=false;
    sizzleSoundSource = stopLoopingSound(sizzleSoundSource); rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    let message = '';
    if (score > highScore) { highScore = score; localStorage.setItem('bubblePopHighScore', highScore); message = isWinner ? 'You Win! New High Score!' : 'New High Score!'; } 
    else { message = isWinner ? 'You Win!' : 'Sorry, you lost!'; }
    endMessageEl.innerText = message;
    if(isWinner){ playSound('win', { gain: 0.5 }); createFirework(); } 
    else { playSound('lose', { gain: 0.5 }); createRain(); }
    finalScoreEl.innerText = score; 
    gameOverEl.style.display = 'flex';
    setTimeout(() => gameOverEl.style.opacity = 1, 10);
}
function createFirework() { const x=Math.random()*canvas.width*0.8+canvas.width*0.1; const y=Math.random()*canvas.height*0.5+canvas.height*0.1; const color=`hsl(${Math.random()*360},100%,50%)`; for(let i=0;i<50;i++){const angle=Math.random()*Math.PI*2;const speed=Math.random()*3+1;fireworks.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,color,size:Math.random()*2+1})}}
function createRain() { for(let i=0;i<100;i++){rain.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,len:Math.random()*20+10,speed:Math.random()*5+2})}}
function handleAimUpdate(clientX,clientY) {
    if(gameState!=='playing' || !playerBubble)return; 
    const rect=canvas.getBoundingClientRect(); 
    aim.x=(clientX-rect.left)*(canvas.width/rect.width); 
    aim.y=(clientY-rect.top)*(canvas.height/rect.height);
    const currentAngle = Math.atan2(aim.y-playerBubble.y,aim.x-playerBubble.x); if (Math.abs(currentAngle - lastAimAngle) > 0.03) { aimClickCounter++; if (aimClickCounter % 3 === 0) { playSound('shick', { gain: 0.7 }); } lastAimAngle = currentAngle; }
}
function handleFire() {
    if(gameState!=='playing'||isFiring||!playerBubble||aim.y>playerBubble.y-20)return; playSound('shoot', { gain: 0.25 });
    const angle=Math.atan2(aim.y-playerBubble.y,aim.x-playerBubble.x),speed=15; playerBubble.vx=Math.cos(angle)*speed; playerBubble.vy=Math.sin(angle)*speed; isFiring=true;
}
function calculateTrajectory() {
    if (!playerBubble) return { path: [], snapPoint: null };

    const angle = Math.atan2(aim.y - playerBubble.y, aim.x - playerBubble.x);
    const speed = 15;
    let ghost = { x: playerBubble.x, y: playerBubble.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed };
    let path = [{x: ghost.x, y: ghost.y}];
    
    for (let i = 0; i < 100; i++) { // Max 100 steps
        ghost.x += ghost.vx;
        ghost.y += ghost.vy;

        if (ghost.x - BUBBLE_RADIUS < 0 || ghost.x + BUBBLE_RADIUS > canvas.width) {
            ghost.vx *= -1;
            path.push({x: ghost.x, y: ghost.y});
        }
        if (ghost.y - BUBBLE_RADIUS < 0) {
            let d = Infinity, snapCoords = null;
            for(let c = 0; c < COLS; c++) {
                if(!grid[0][c]) {
                    const dist = Math.abs(ghost.x - (offsetX + c * HEX_WIDTH + ((0 + gridRowOffset) % 2) * BUBBLE_RADIUS));
                    if(dist < d) { d = dist; snapCoords = {r:0, c}; }
                }
            }
             if (snapCoords) {
                return { path, snapPoint: { x: offsetX + snapCoords.c * HEX_WIDTH + ((snapCoords.r + gridRowOffset) % 2) * BUBBLE_RADIUS, y: offsetY + snapCoords.r * HEX_HEIGHT } };
            }
            return { path, snapPoint: null };
        }

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (grid[r][c] && Math.hypot(ghost.x - grid[r][c].x, ghost.y - grid[r][c].y) < COLLISION_RADIUS) {
                    let d = Infinity, snapCoords = null;
                    const neighbors = getNeighbors(r, c);
                    for (const n of neighbors) {
                        if (!grid[n.r][n.c]) {
                            const nx = offsetX + n.c * HEX_WIDTH + ((n.r + gridRowOffset) % 2) * BUBBLE_RADIUS;
                            const ny = offsetY + n.r * HEX_HEIGHT;
                            const dist = Math.hypot(ghost.x - nx, ghost.y - ny);
                            if (dist < d) { d = dist; snapCoords = n; }
                        }
                    }
                    if (snapCoords) {
                         return { path, snapPoint: { x: offsetX + snapCoords.c * HEX_WIDTH + ((snapCoords.r + gridRowOffset) % 2) * BUBBLE_RADIUS, y: offsetY + snapCoords.r * HEX_HEIGHT } };
                    }
                    return { path, snapPoint: null };
                }
            }
        }
    }
    return { path, snapPoint: null };
}

const delay = ms => new Promise(res => setTimeout(res, ms));
const offscreenCanvas = document.createElement('canvas');
const offscreenCtx = offscreenCanvas.getContext('2d');

function createPopEffectForText(text, text2 = '', yOffset = 0) {
    playSound('pop', { gain: 0.6, playbackRate: 1.2 });
    const FONT_SIZE = 100;
    
    // Configure the invisible, off-screen canvas
    offscreenCanvas.width = canvas.width;
    offscreenCanvas.height = canvas.height;
    offscreenCtx.font = `bold ${FONT_SIZE}px 'Fredoka One', cursive`;
    
    // Calculate measurements using the off-screen context
    const metrics1 = offscreenCtx.measureText(text);
    const metrics2 = text2 ? offscreenCtx.measureText(text2) : { width: 0, actualBoundingBoxAscent: 0, actualBoundingBoxDescent: 0 };
    const totalWidth = Math.max(metrics1.width, metrics2.width);
    const textHeight = metrics1.actualBoundingBoxAscent + metrics1.actualBoundingBoxDescent;
    const totalHeight = text2 ? textHeight * 2.2 : textHeight;
    const startX = (canvas.width / 2) - (totalWidth / 2);
    const startY = (canvas.height / 2) - (totalHeight / 2) + yOffset;

    // Draw the text to the INVISIBLE off-screen canvas to get pixel data
    offscreenCtx.fillStyle = "white";
    offscreenCtx.textBaseline = 'alphabetic';
    
    const text1X = (canvas.width / 2) - (metrics1.width / 2);
    offscreenCtx.fillText(text, text1X, startY + textHeight);
    
    if(text2) {
      const text2X = (canvas.width / 2) - (metrics2.width / 2);
      offscreenCtx.fillText(text2, text2X, startY + textHeight * 2.2);
    }
    
    // Sample the pixels from the INVISIBLE off-screen canvas
    const sampleAreaX = startX - 10;
    const sampleAreaY = startY;
    const sampleAreaWidth = totalWidth + 20;
    const sampleAreaHeight = totalHeight + 10;
    const imageData = offscreenCtx.getImageData(sampleAreaX, sampleAreaY, sampleAreaWidth, sampleAreaHeight);
    const sampleDensity = 8;
    for(let y = 0; y < imageData.height; y += sampleDensity) {
        for (let x = 0; x < imageData.width; x += sampleDensity) {
            const alpha = imageData.data[(y * imageData.width + x) * 4 + 3];
            if (alpha > 128) {
                createIntroPopEffect(sampleAreaX + x, sampleAreaY + y, 'white');
            }
        }
    }
}

// Animate values for the intro text, now with a start and end scale
function animateIntroValue(startScale, endScale, duration) {
    return new Promise(resolve => {
        let start = null;
        const scaleRange = endScale - startScale;
        const step = (timestamp) => {
            if (!start) start = timestamp;
            const progress = Math.min((timestamp - start) / duration, 1);
            
            introState.scale = startScale + scaleRange * progress;
            introState.opacity = progress;

            if (progress < 1) {
                window.requestAnimationFrame(step);
            } else {
                introState.scale = endScale;
                introState.opacity = 1;
                resolve();
            }
        };
        window.requestAnimationFrame(step);
    });
}

async function startIntro() {
    // --- First "Pop!" ---
    introState.text = 'Pop!';
    await animateIntroValue(0.03, 1, 600); // Animate text into view
    await delay(1500); // Hold the text on screen
    // POP IT:
    introState.opacity = 0; // Make the text instantly invisible
    createPopEffectForText(introState.text, '', -20); // Create the particles immediately
    await delay(1000); // Wait for particles to animate

    // --- Second "Pop!" ---
    introState.text = 'Pop!';
    await animateIntroValue(0.03, 1, 600); // Animate text back into view
    await delay(1500); // Hold it
    // POP IT:
    introState.opacity = 0; // Instantly invisible
    createPopEffectForText(introState.text, '', -20);
    await delay(1000);

    // --- "Bubble Stop!" ---
    introState.text = 'Bubble'; // This will draw "Bubble" and "Stop!"
    await animateIntroValue(0.03, 1, 800);
    await delay(1200);

    // Shake it
    introState.shakeDuration = 25;
    await delay(450);
    introState.shakeDuration = 0;
    await delay(200);

    // Final Pop
    introState.opacity = 0; // Instantly invisible
    createPopEffectForText('Bubble', 'Stop!');
    await delay(1500); // Give the final pop effect more time to finish

    // Transition to rules screen
    rulesOverlay.style.display = 'flex';
    await delay(50);
    rulesOverlay.style.opacity = 1;
    gameState = 'rules';
}

function drawIntroAnimation() {

    ctx.save();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    let shakeX = 0; let shakeY = 0;
    if (introState.shakeDuration > 0) {
        introState.shakeDuration--;
        shakeX = (Math.random() - 0.5) * introState.shakeMagnitude;
        shakeY = (Math.random() - 0.5) * introState.shakeMagnitude;
    }
    
    const FONT_SIZE = 100;
    ctx.font = `bold ${FONT_SIZE}px 'Fredoka One', cursive`;
    ctx.fillStyle = `rgba(255, 255, 255, ${introState.opacity})`;
    ctx.shadowColor = "rgba(0,0,0,0.4)";
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = 5;
    ctx.shadowOffsetY = 5;

    const centerX = canvas.width / 2 + shakeX;
    const centerY = canvas.height / 2 + shakeY;

    ctx.translate(centerX, centerY);
    ctx.scale(introState.scale, introState.scale);
    ctx.translate(-centerX, -centerY);

    if (introState.text === 'Bubble') {
        ctx.fillText('Bubble', centerX, centerY - 55);
        ctx.fillText('Stop!', centerX, centerY + 55);
    } else {
        ctx.fillText(introState.text, centerX, centerY-20);
    }
    
    ctx.restore();
}
// This function updates the splash screen's animation state (opacity, phase) over time.
function updateSplashScreen() {
    splashTimer++;
    switch (splashPhase) {
        case 'fade-in':
            splashOpacity = Math.min(1.0, splashTimer / SPLASH_FADE_FRAMES);
            if (splashTimer >= SPLASH_FADE_FRAMES) {
                splashPhase = 'hold';
                splashTimer = 0; // Reset timer for the next phase
            }
            break;
        case 'hold':
            if (splashTimer >= SPLASH_HOLD_FRAMES) {
                splashPhase = 'fade-out';
                splashTimer = 0; // Reset timer for the next phase
            }
            break;
        case 'fade-out':
            splashOpacity = Math.max(0.0, 1.0 - (splashTimer / SPLASH_FADE_FRAMES));
            if (splashTimer >= SPLASH_FADE_FRAMES) {
                isFirstLoad = false; // The flag is flipped here!
                gameState = 'intro'; // Transition to the text intro
                startIntro(); // Kick off the text intro's animation sequence
            }
            break;
    }
}

// This function draws the splash screen image onto the canvas.
function renderSplashScreen() {
    // Draw a black background
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (splashImageLoaded) {
        ctx.globalAlpha = splashOpacity;
        const imgW = splashImage.width;
        const imgH = splashImage.height;
        const aspect = imgW / imgH;
        let drawW = canvas.width * 0.9;
        let drawH = drawW / aspect;
        if (drawH > canvas.height * 0.9) {
            drawH = canvas.height * 0.9;
            drawW = drawH * aspect;
        }
        ctx.drawImage(splashImage, (canvas.width - drawW) / 2, (canvas.height - drawH) / 2, drawW, drawH);
        ctx.globalAlpha = 1.0; // Reset global alpha
    }
}

function runGame() {
    initBackground();
    // Only display high score initially.
    highScore = parseInt(localStorage.getItem('bubblePopHighScore')) || 0;
    highScoreEl.innerText = highScore;

    // Check if this is the first time loading.
    if (isFirstLoad) {
        gameState = 'splash'; // Start with the splash screen.
    } else {
        // If not the first load (i.e., a restart), skip intros and go to the play button.
        gameState = 'pregame';
        startOverlay.style.display = 'flex';
        setTimeout(() => startOverlay.style.opacity = 1, 20);
    }
    
    // Start the main game loop, which will now handle the current gameState.
    gameLoop();
}

document.getElementById('continue-button').addEventListener('click', async () => {
    await initAudio(); 
    playSound('click',{gain:0.4}); 
    
    // Fade out rules screen
    rulesOverlay.style.opacity = 0;
    await delay(500); // Wait for the CSS transition
    rulesOverlay.style.display = 'none';
    
    // Fade in start screen
    startOverlay.style.opacity = 0;
    startOverlay.style.display = 'flex';
    await delay(20);
    startOverlay.style.opacity = 1;

    gameState = 'pregame';
});

document.getElementById('play-button').addEventListener('click', async ()=>{
    playSound('click',{gain:0.4});
    startOverlay.style.opacity = 0;
    await delay(500);
    startOverlay.style.display='none';
    init(); // init() is called here to set up the game board.
    gameState='playing';
});

document.getElementById('play-again-button').addEventListener('click', async ()=>{
    playSound('click',{gain:0.4});
    gameOverEl.style.opacity = 0;
    await delay(500);
    gameOverEl.style.display='none';
    init(); 
    startOverlay.style.opacity = 0;
    startOverlay.style.display='flex';
    await delay(20);
    startOverlay.style.opacity = 1;
    gameState = 'pregame';
});

document.getElementById('restart-button').addEventListener('click', async ()=>{
    playSound('click',{gain:0.4});
    if(gameState==='playing'&&confirm('Are you sure you want to restart the game?')){
        init(); 
        if (gameState === 'paused') {
            pauseOverlay.style.opacity = 0;
            await delay(500);
            pauseOverlay.style.display = 'none';
        }
        startOverlay.style.opacity = 0;
        startOverlay.style.display='flex';
        await delay(20);
        startOverlay.style.opacity = 1;
        gameState='pregame';
    } else if(gameState!=='playing' && gameState!=='rules' && gameState!=='intro'){
        init(); 
        if (gameOverEl.style.display === 'flex') {
            gameOverEl.style.opacity = 0;
            await delay(500);
            gameOverEl.style.display = 'none';
        }
        if (pauseOverlay.style.display === 'flex') {
            pauseOverlay.style.opacity = 0;
            await delay(500);
            pauseOverlay.style.display = 'none';
        }
        startOverlay.style.opacity = 0;
        startOverlay.style.display='flex';
        await delay(20);
        startOverlay.style.opacity = 1;
        gameState='pregame';
    }
});

document.getElementById('level-up-continue-button').addEventListener('click', async () => { 
    playSound('click',{gain:0.4}); 
    levelUpOverlay.style.opacity = 0;
    await delay(500);
    levelUpOverlay.style.display = 'none'; 
    resetForNextLevel(); 
    gameState = 'playing'; 
});

audioToggleButton.addEventListener('click', () => {
    isMuted = !isMuted; audioToggleButton.innerText = isMuted ? "Sound: OFF" : "Sound: ON";
    if (isMuted) { 
        sizzleSoundSource = stopLoopingSound(sizzleSoundSource); 
        rainbowSoundSource = stopLoopingSound(rainbowSoundSource); 
    } else { 
        initAudio();
        playSound('click', {gain: 0.4}); 
        if (playerBubble && playerBubble.type === 'bomb' && gameState === 'playing') sizzleSoundSource = playLoopingSound('sizzle', { gain: 0.15 }); 
        if (playerBubble && playerBubble.type === 'rainbow' && gameState === 'playing') { rainbowSoundSource = playLoopingSound('rainbow', { gain: 0.2 }); } 
    }
});
pauseButton.addEventListener('click', () => {
    if (gameState === 'playing') {
        gameState = 'paused';
        pauseOverlay.style.display = 'flex';
        setTimeout(() => pauseOverlay.style.opacity = 1, 10);
        sizzleSoundSource = stopLoopingSound(sizzleSoundSource);
        rainbowSoundSource = stopLoopingSound(rainbowSoundSource);
    }
});
resumeButton.addEventListener('click', async () => {
    if (gameState === 'paused') {
        pauseOverlay.style.opacity = 0;
        await delay(500);
        pauseOverlay.style.display = 'none';
        gameState = 'playing';
        if (!isMuted && playerBubble) {
            if (playerBubble.type === 'bomb') sizzleSoundSource = playLoopingSound('sizzle', { gain: 0.15 });
            if (playerBubble.type === 'rainbow') rainbowSoundSource = playLoopingSound('rainbow', { gain: 0.2 });
        }
    }
});

if(isMobile){canvas.addEventListener('touchmove',e=>{e.preventDefault();handleAimUpdate(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});canvas.addEventListener('touchend',e=>{e.preventDefault();handleFire()},{passive:false})}else{canvas.addEventListener('mousemove',e=>{handleAimUpdate(e.clientX,e.clientY)});canvas.addEventListener('click',handleFire)}
function initBackground() { bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight; backgroundBubbles = []; let bubbleCount = 30; for (let i = 0; i < bubbleCount; i++) { backgroundBubbles.push({ x: Math.random() * bgCanvas.width, y: Math.random() * bgCanvas.height, radius: Math.random() * 25 + 10, speed: Math.random() * 1 + 0.5, opacity: Math.random() * 0.3 + 0.1 });}}
function updateBackgroundBubbles() { for (let i = 0; i < backgroundBubbles.length; i++) { const b = backgroundBubbles[i]; b.y -= b.speed; if (b.y < -b.radius) { b.y = bgCanvas.height + b.radius; b.x = Math.random() * bgCanvas.width; b.speed = Math.random() * 1 + 0.5; b.radius = Math.random() * 25 + 10; }}}
function drawBackgroundBubbles() { bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height); for (let i = 0; i < backgroundBubbles.length; i++) { const b = backgroundBubbles[i]; let grad = bgCtx.createRadialGradient( b.x - b.radius * 0.3, b.y - b.radius * 0.3, 0, b.x, b.y, b.radius ); grad.addColorStop(0, `rgba(255, 255, 255, ${b.opacity + 0.2})`); grad.addColorStop(1, `rgba(174, 222, 252, ${b.opacity})`); bgCtx.fillStyle = grad; bgCtx.beginPath(); bgCtx.arc(b.x, b.y, b.radius, 0, Math.PI * 2); bgCtx.fill();}}
window.addEventListener('resize', initBackground);

function gameLoop() {
    updateBackgroundBubbles();
    drawBackgroundBubbles();

    // --- LOGIC UPDATES ---
    if (gameState === 'splash') {
        updateSplashScreen();
    } else if (gameState === 'playing') {
        update();
    }
    updatePopAnimations();
    if (gameState === 'gameover') {
        if (fireworks.length > 0) updateFireworks();
        if (rain.length > 0) updateRain();
    }

    // --- RENDERING ---
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (gameState === 'splash') {
        renderSplashScreen();
    } else if (gameState === 'intro') {
        drawIntroAnimation();
    } else if (gameState !== 'rules' && gameState !== 'pregame') {
        drawGrid();
        if (gameState === 'playing' || gameState === 'paused') drawBubble(ctx, playerBubble);
        if (gameState === 'playing' && !isFiring) drawAimingLine();
        drawGameOverLine();
    }

    drawPopAnimations();
    drawFloatingPoints();
    drawBombSparks();
    drawShockwaves();
    drawStaticSparks();
    drawStaticBubbleSparks();
    drawComboAnnouncer();
    drawGlitterParticles();

    if (gameState === 'gameover') {
        drawFireworks();
        drawRain();
    }

    requestAnimationFrame(gameLoop);
}

runGame();
</script>
</body>
</html>
